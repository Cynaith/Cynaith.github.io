<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL性能调优-9.MySQL数据库Schema设计的性能优化</title>
      <link href="/2020/06/08/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-9-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Schema%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/06/08/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-9-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Schema%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章-MySQL数据库Schema设计的性能优化"><a href="#第九章-MySQL数据库Schema设计的性能优化" class="headerlink" title="第九章 MySQL数据库Schema设计的性能优化"></a>第九章 MySQL数据库Schema设计的性能优化</h2><h3 id="高效的模型设计"><a href="#高效的模型设计" class="headerlink" title="高效的模型设计"></a>高效的模型设计</h3><p>数据库Scnema满足的范式级别越高则该Schema设计的越优秀。</p><ul><li>适度冗余 - 让Query尽量减少Join</li><li>大字段垂直分拆 - summary表优化<br>与适度冗余相反，将大字段并且访问频率相对少的字段拆分。</li><li>大表水平拆分 - 基于类型的分拆优化<br>如通过标识字段标识出管理员发布或是普通用户发布，减少检索成本。</li><li>统计表 - 准实时优化  </li></ul><h3 id="合适的数据类型"><a href="#合适的数据类型" class="headerlink" title="合适的数据类型"></a>合适的数据类型</h3><ol><li>通过选用更『小』的数据类型减少存储空间。</li><li>通过更合适的数据类型加速数据的比较。</li></ol><h4 id="数字日期类型"><a href="#数字日期类型" class="headerlink" title="数字日期类型"></a>数字日期类型</h4><p>对于数字的存储，一般使用到浮点型数据的场合也不应该太多。主要出于两个原因，一个是浮点型 数据本身实际上是一个并不精确的数字，只是一个近似值，<br>另一个原因就是完全可以通过乘以一个固定 的系数转换为整型数据来存放。这样不仅可以解决数据不精确的问题，同时也让数据的处理更为高效。  </p><p>时间存储格式总类并不是太多，我们常用的主要就是 DATETIME，DATE 和 TIMESTAMP 这三种了。从存储空间来看 TIMESTAMP 最少，四个字节，<br>而其他两种数据类型都是八个字节，多了一倍。而TIMESTAMP 的 缺点在于他只能存储从1970 年之后的时间，而另外两种时间类型可以存放最早从1001年开始的时间。<br>如果有需要存放早于 1970 年之前的时间的需求，我们必须放弃 TIMESTAMP 类型，但是只要我们不需要使用 1970 年之前的时间，最好尽量使用 TIMESTAMP 来减少存储空间的占用。</p><h4 id="字符存储类型"><a href="#字符存储类型" class="headerlink" title="字符存储类型"></a>字符存储类型</h4><p><strong>CHAR</strong>类型属于静态长度类型，不管实际存放多长数据，后面都会用空格补齐，所以实际数据中需要在最后存储空格，则不能使用CHAR类型。  </p><p><strong>VARCHAR</strong>类型属于动态存储长度类型，5.0.3版本前最大只能存255字符，此后可以存储65535 bytes的数据。<br>注: MySQL 会在每个 VARCHAR 数据中使用 1 个或 者 2 个字节用来存放 VARCHAR 数据的实际长度，当我们的实际数据在255字节之内的时候，<br>会使用 1 字节 来存放实际长度，而大于 255 字节的时候，则需要使用 2 字节来存放。  </p><p><strong>TINYTEXT，TEXT，MEDIUMTEXT 和 LONGTEXT</strong> 这四种类型同属于一种存储方式，都是动态存储长度类型。<br>与CHAR和VARCHAR的不同:</p><ol><li>不能设置默认值</li><li>只有TEXT可以设置大小</li><li>这四种类型的索引必须指定前缀长度 </li></ol><p><strong>BIT</strong>类型: 默认大小为1 最大为64bits  </p><p><strong>SET和ENUM</strong>类型使用在较少变化状态并且值比较少的字段。</p><h4 id="规范的对象命名"><a href="#规范的对象命名" class="headerlink" title="规范的对象命名"></a>规范的对象命名</h4><ol><li>数据库和表名应尽可能和所服务的业务模块名一致。</li><li>服务于同一子模块的一类表尽量以子模块名(或部分单词)为前缀或后缀。</li><li>表名应尽量包含与所存放数据相对应的单词。</li><li>字段名称也尽量保持和实际数据相对应。</li><li>索引名称尽量包含所有的索引键字段名或者缩写，各字段名在索引名中的顺序应与索引键在 索引中的索引顺序一致。</li><li>约束等其他对象也应该尽可能包含所属表或其他对象的名称，以表名各自关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-8.MySQL数据库Query的优化</title>
      <link href="/2020/06/08/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-8-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Query%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2020/06/08/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-8-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93Query%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库Query的优化"><a href="#MySQL数据库Query的优化" class="headerlink" title="MySQL数据库Query的优化"></a>MySQL数据库Query的优化</h2><h3 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h3><p>在MySQL中有一个专门负责优化SELECT语句的优化器模块。主要功能是通过计算分析系统中收集的各种统计信息，<br>为客户端请求的Query给出他认为的最优的执行计划。</p><h3 id="Optimizer-基本工作原理"><a href="#Optimizer-基本工作原理" class="headerlink" title="Optimizer 基本工作原理"></a>Optimizer 基本工作原理</h3><p>当客户端向MySQL请求一条Query，到命令解析器模块完成请求分类区别出是 SELECT 并转发给 Query Optimizer 之后，<br>Query Optimizer 首先会对整条 Query 进行，优化处理掉一些常量表达式的预算，直接换算成常量值。<br>并对 Query 中的查询条件进行简化和转换，如去掉一些无用或者显而易见的条件，结构调整等等。<br>然后则是分析 Query 中的 Hint 信息(如果有)，看显示 Hint 信息是否可以完全确定该 Query 的执行计划。<br>如果没有 Hint 或者 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</p><h3 id="Query语句优化的基本思路和原则"><a href="#Query语句优化的基本思路和原则" class="headerlink" title="Query语句优化的基本思路和原则"></a>Query语句优化的基本思路和原则</h3><ul><li><p>(基本思路)</p><ol><li>优化更需要优化的 Query;</li><li>定位优化对象的性能瓶颈;</li><li>明确的优化目标;</li><li>从 Explain 入手;</li></ol></li><li><p>(原则)</p><ol start="5"><li>多使用 profile</li><li>永远用小结果集驱动大的结果集;</li><li>尽可能在索引中完成排序;</li><li>只取出自己需要的 Columns;</li><li>仅仅使用最有效的过滤条件;</li><li>尽可能避免复杂的Join和子查询;</li></ol></li><li><p>优化更需要优化的 Query<br>一般来说，高并发低消耗的Query比低并发高消耗更应该优化。</p></li><li><p>定位优化对象的性能瓶颈<br>拿到一条需要优化的Query之后，首先要判断Query的瓶颈是IO还是CPU(如数据运算)<br>注: 5.0系列版本中，可以通过自带的PROFILING功能清楚的找出Query瓶颈所在。(5.1非正式版除外)</p></li><li><p>明确的优化目标<br>首先要清楚的了解数据库目前的整体状态，同时也要清楚的知道数据库中与该Query相关的数据库对象的各种信息。还要了解该 Query 在整个应用系统中所实现的功能。</p><p>如果该Query 实现的应用 系统功能比较重要，我们就必须让目标更偏向于理想值一些，即使在其他某些方面作出一些让步与牺 牲，比如调整 schema 设计，调整索引组成等，<br>可能都是需要的。而如果该 Query 所实现的是一些并 是太关键的功能，那我们可以让目标更偏向悲观值一些，而尽量保证其他更重要的Query 的性能。</p></li><li><p>从Explain入手<br>根据以上三点我们可以得知优化的目标，所以我们要从Explain入手查看Query在数据库中是以一个什么样的执行计划来实现的。</p></li><li><p>永远用小结果集驱动大的结果集<br>MySQL的Join是通过嵌套循环来实现的。驱动结果集越大，需要的循环就越多。IO消耗以及CPU消耗也就越多。</p></li><li><p>只取出自己需要的Columns，尤其是在需要排序的时候<br>从网络带宽、网络传输的缓冲区来看，数据越多，消耗越大。<br>MySQL4.1后，排序会一次性将所需要的Columns全部取出，在排序区排序。</p></li><li><p>仅仅使用最有效的过滤条件<br>WHERE子句过滤条件不是越多越好。<br>要保证索引键长度尽量小(UTF-8字符集占用3个字节)。</p></li><li><p>尽量避免复杂的Join和子查询<br>可以将复杂的Join语句拆分成多个简单的Query语句，牺牲单个query的短暂响应时间而提高整体的处理能力也是非常值得的。</p></li></ul><h3 id="Explain的使用"><a href="#Explain的使用" class="headerlink" title="Explain的使用"></a>Explain的使用</h3><ul><li>ID: Query Optimizer所选定的执行计划中查询的序列号。</li><li>Select_type: 所使用的查询类型，主要有以下这几种查询类型<ul><li>DEPENDENT SUBQUERY: 子查询中内层的第一个SELECT，依赖于外部查询的结果集。</li><li>DEPENDENT UNION: 子查询中的UNION，且为UNION中从第二个SELECT开始的后面所有的SELECT，同样依赖于外部查询的结果集。</li><li>PRIMARY: 子查询中最外层查询，不是主键查询。</li><li>SIMPLE: 除子查询或UNION之外的其他查询。</li><li>SUBQUERY: 子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集。</li><li>UNCACHEABLE SUBQUERY: 结果集无法缓存的子查询。</li><li>UNION: UNION语句中第二个SELECT开始的后面所有SELECT，第一个SELECT为PRIMARY</li><li>UNION RESULT: UNION中的合并结果。</li></ul></li><li>Table: 显示这一步所访问的数据库中的表的名称。</li><li>Type: 对表的访问方式<ul><li>all: 全表扫描</li><li>const: 读常量，且最多只有一条记录匹配(如唯一索引)。</li><li>eq_ref: 最多只会有一条匹配结果，一般是通过主键或者唯一索引来访问。</li><li>fulltext: </li><li>index: 全索引扫描</li><li>index_merge: 查询中同时使用两个(或更多)索引，然后对索引结果进行merge 之后再读取表数据。</li><li>index_subquery: 子查询中的返回结果字段组合是一个索引(或索引组合)，但不是一个主键或者唯一索引。</li><li>rang: 索引范围扫描。</li><li>ref: Join 语句中被驱动表索引引用查询。</li><li>ref_or_null: 与 ref 的唯一区别就是在使用索引引用查询之外再增加一个空值的查询。<br>_ system: 系统表，表中只有一行数据。</li><li>unique_subquery: 子查询中的返回结果字段组合是主键或者唯一约束。</li></ul></li><li>Possible_keys: 该查询可以利用的索引，如果没有任何索引可以使用，就会显示成null，这一项内容对于优化时候索引的调整非常重要。</li><li>Key: MySQL Query Optimizer 从 possible_keys中选择所使用的索引。</li><li>Key_len: 被选中使用索引的长度。</li><li>Ref: 列出是通过常量(const)，还是某个表的某个字段(如果是join)来过滤(通过 key)的。</li><li>Rows: MySQL Query Optimizer通过系统收集到的统计信息估算出来的结果集记录条数。</li><li>Extra: 查询每一步实现的额外细节信息</li></ul><h3 id="Profiling的使用"><a href="#Profiling的使用" class="headerlink" title="Profiling的使用"></a>Profiling的使用</h3><ul><li>开启profiling参数<br><code>set profiling = 1;</code></li><li>在开启 Query Profiler 功能之后，MySQL 就会自动记录所有执行的 Query 的 profile 信息了</li><li>获取系统中保存的所有 Query 的 profile 概要信息<br><code>show profiles;</code></li><li>针对单个 Query 获取详细的 profile 信息<br><code>show profile cpu, block io for query (概要信息中ID);</code> </li></ul><h3 id="合理设计并使用索引"><a href="#合理设计并使用索引" class="headerlink" title="合理设计并使用索引"></a>合理设计并使用索引</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>MySQL中的B-Tree索引的物理文件大多是以Balance Tree的结构来存储的。各种存储引擎存放时都会对存储结构稍作改造(Innodb存储引擎使用的实际上是B+Tree<br>(在每一个Leaf Node上面除了存放索引键相关信息之外，还存储了指向该Leaf Node相邻的后一个Lead Node的指针信息))。<br>Innodb存在两种不同形式的索引，一种是Cluster形式的主键索引(除主键外还包括其他字段数据)，一种是普通的B-Tree索引(只存放主键信息)。所以，在Innodb中通过主键来访问数据效率是非常高的。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>弊端:   </p><ol><li>仅仅只能满足 =、IN、&lt;=&gt; 不能使用范围查询。</li><li>不能排序</li><li>不能利用部分索引建查询</li><li>不能表扫描</li><li>遇到大量Hash值相等情况后性能低<h4 id="Full-text索引-全文索引"><a href="#Full-text索引-全文索引" class="headerlink" title="Full-text索引(全文索引)"></a>Full-text索引(全文索引)</h4>仅在MyISAM中支持 仅支持CHAR、VARCHAR、TEXT</li></ol><h4 id="R-Tree"><a href="#R-Tree" class="headerlink" title="R-Tree"></a>R-Tree</h4><p>主要用来解决空间数据检索的问题。</p><h4 id="索引的利处"><a href="#索引的利处" class="headerlink" title="索引的利处"></a>索引的利处</h4><p>提高数据检索效率、降低排序成本、降低CPU资源消耗</p><h4 id="索引的弊端"><a href="#索引的弊端" class="headerlink" title="索引的弊端"></a>索引的弊端</h4><p>索引是独立于基础数据之外的另一部分数据，会增加IO消耗与CPU消耗。</p><h4 id="如何判断是否需要索引"><a href="#如何判断是否需要索引" class="headerlink" title="如何判断是否需要索引"></a>如何判断是否需要索引</h4><ol><li>较频繁的作为查询条件的字段应该创建索引。</li><li>唯一性太差的字段不适合单独创建索引</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在WHERE子句中的字段不该创建索引</li></ol><h4 id="单键索引还是组合索引"><a href="#单键索引还是组合索引" class="headerlink" title="单键索引还是组合索引"></a>单键索引还是组合索引</h4><p>只要不是其中某个过滤字段在大多数场景下都能过滤出90%以上的数据，而且其他的过滤字段会存在频繁的更新，我一般更倾向于创建组合索引，尤其是在并发量较高的场景下更是应该如此。</p><p>还应该 尽量让一个索引被多个 Query 语句所利用，尽量减少同一个表上面索引的数量，减少因为数据更新所带 来的索引更新成本，同时还可以减少因为索引所消耗的存储空间。</p><h4 id="Query的索引选择"><a href="#Query的索引选择" class="headerlink" title="Query的索引选择"></a>Query的索引选择</h4><ol><li>在Query 中增加 Hint 提 示 MySQL Query Optimizer 告诉他该使用哪个索引而不该使用哪个索引。(MySQL默认使用的索引并不一定是最优索引)</li><li>调整查询条件来达到相同的目的。</li></ol><p>建议:  </p><ol><li>对于单键索引，尽量选择针对当前 Query 过滤性更好的索引。</li><li>在选择组合索引的时候，当前 Query 中过滤性最好的字段在索引字段顺序中排列越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前 Query 的 WHERE 子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整 Query 的写法来达到选择合适索引的目的而减少通过使用 Hint 人为控制索引的选择，因为这会使后期的维护成本增加，同时增加维护所带来的潜在风险。</li></ol><p>MySQL中索引的限制:  </p><ol><li>MyISAM 存储引擎索引键长度总和不能超过 1000 字节。</li><li>BLOB 和 TEXT 类型的列只能创建前缀索引。</li><li>MySQL 目前不支持函数索引。</li><li>使用不等于(!= 或者 &lt;&gt;)的时候 MySQL 无法使用索引。</li><li>过滤字段使用了函数运算后(如 abs(column))，MySQL 无法使用索引。</li><li>Join 语句中 Join 条件字段类型不一致的时候 MySQL 无法使用索引。</li><li>使用 LIKE 操作的时候如果条件以通配符开始( ‘%abc…’)MySQL 无法使用索引。</li><li>使用非等值查询的时候 MySQL 无法使用 Hash 索引。</li></ol><h4 id="Join实现原理及优化"><a href="#Join实现原理及优化" class="headerlink" title="Join实现原理及优化"></a>Join实现原理及优化</h4><p>原理:<br>通过驱动表 的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与 Join，<br>则再通过前两个表的 Join 结果集作为循环基础数据， 再一次通过循环查询条件到第三个表中查询数据，如此往复。</p><p>优化:  </p><ol><li>尽可能减少 Join 语句中的 Nested Loop 的循环总次数。</li><li>优先优化 Nested Loop 的内层循环。</li><li>保证 Join 语句中被驱动表上 Join 条件字段已经被索引。</li><li>当无法保证被驱动表的 Join 条件字段被索引且内存资源充足的前提下，不要太吝惜 Join Buffer 的设置。</li></ol><h4 id="Order-By、Group-By、Distinct-优化"><a href="#Order-By、Group-By、Distinct-优化" class="headerlink" title="Order By、Group By、Distinct 优化"></a>Order By、Group By、Distinct 优化</h4><ul><li><p>Order By</p><ul><li>利用有序索引可以直接取得有序数据，在调整索引之前，还需要评估调整改索引对其他Query所带来的影响。</li><li>无法使用索引时，应采用MySQL4.1版本后改进的排序算法。<ul><li>加大 max_length_for_sort_data 参数的设置。(增大排序区大小，使其能够一次扫描，避免二次扫描消耗IO)</li><li>去掉不必要的返回字段。 </li><li>增大 sort_buffer_size 参数设置。</li></ul></li></ul></li><li><p>Group By</p><ul><li><p>使用松散(Loose)索引扫描实现 GROUP BY<br>实际上就是当 MySQL 完全利用索引扫描来实现 GROUP BY 的 时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。  </p><ul><li>使用松散索引扫描需要满足以下条件:  <ol><li>查询在单一表上。</li><li>group by指定的所有列是索引的一个最左前缀，并且没有其它的列。比如表t1（ c1,c2,c3,c4）上建立了索引（c1,c2,c3）。<br>如果查询包含“group by c1,c2”，那么可以使用松散索引扫描。但是“group by c2,c3”(不是索引最左前缀)和“group by c1,c2,c4”(c4字段不在索引中)。</li><li>如果在选择列表select list中存在聚集函数，只能使用 min()和max()两个聚集函数，并且指定的是同一列（如果min()和max()同时存在）。这一列必须在索引中，且紧跟着group by指定的列。比如，select t1,t2,min(t3),max(t3) from t1  group by c1,c2。</li><li>如果查询中存在除了group by指定的列之外的索引其他部分，那么必须以常量的形式出现（除了min()和max()两个聚集函数）。比如，select c1,c3 from t1 group by c1,c2不能使用松散索引扫描。而select c1,c3 from t1 where c3 =  3 group by c1,c2可以使用松散索引扫描。</li><li>索引中的列必须索引整个数据列的值(full column values must be indexed)，而不是一个前缀索引。比如，c1 varchar(20), INDEX (c1(10)),这个索引没发用作松散索引扫描。 </li><li>5.5后AVG(DISTINCT), SUM(DISTINCT)和COUNT(DISTINCT)可以使用松散索引扫描。COUNT(DISTINCT)可以使用多列参数。</li><li>5.5后可以在查询中没有group by和distinct条件。 <code>SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;</code></li></ol></li></ul></li><li><p>使用紧凑(Tight)索引扫描实现 GROUP BY<br>紧凑索引扫描实现 GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成 GROUP BY 操作得到相应结果。  </p></li><li><p>使用临时表实现 GROUP BY<br>前面两种 GROUP BY 的实现方式都是在有可以利用的索引的时候使用的，当 MySQL Query Optimizer 无法找到合适的索引可以利用的时候，<br>就不得不先读取需要的数据，然后通过临时表来完成 GROUP BY 操作。</p><p>如果不遵守最左原则，where b = xxx，就会使用紧凑索引遍历的方式，进行全表扫表。而我们如果真的有些情况，<br>需要查出符合 B 条件但对 A 不进行限制的情况，应该如何处理，可能有些同学会新开一个独立索引仅包含 B 列，<br>这样虽然能达到我们的目的，但难免有些多余。mysql 也是也能很好的进行跳跃松散索引扫描，只是 mysql 优化器无法自动进行，<br>必须在查询语句中进行必要的声明。 select * from xxx where B = xxx group by A; 添加 group by 字段后，<br>会先根据 A 索引分组后，会在每个 A 的范围内使用索引进行快速查询定位所需要的 B 列，这就叫做松散索引扫描，<br>比新建一个索引的效率会慢 A 的 distinct 倍，但省去了新索引的消耗。</p></li></ul></li></ul><h4 id="DISTINCT-的实现与优化"><a href="#DISTINCT-的实现与优化" class="headerlink" title="DISTINCT 的实现与优化"></a>DISTINCT 的实现与优化</h4><p>DISTINCT与GROUP BY同样可以通过松散索引扫描或者紧凑索引扫描来实现，在无法使用DISTINCT时，MySQL只能通过临时表来完成。(仅DISTINCT的Query无法使用索引时，不会对临时表数据进行filesort，如果使用Group By 就无法避免filesort)</p><ul><li>松散索引<br><code>explain select distinct id from user\G</code> 的 Extra 为 <code>Using index for group-by</code><br>在实现 DISTINCT 的过程中，同样也是需要分组的，然后再从每组数据中取出一条返回给客户端。</li><li>紧凑索引<br>使用where时，会先(Using Where)回表扫描，再利用索引直接Using index。</li><li>无法单独使用索引<br>会使用临时表</li><li>与Group By结合<br>使用聚合函数会filesort</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-7.MySQL数据库锁定机制</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-7-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%AE%9A%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-7-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%AE%9A%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库锁定机制"><a href="#MySQL数据库锁定机制" class="headerlink" title="MySQL数据库锁定机制"></a>MySQL数据库锁定机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。</p><ul><li><p>行级锁定</p><ul><li>特点: 所定对象颗粒度小，能够给予应用程序尽可能大的并发处理能力。</li><li>弊端: 容易发生死锁</li></ul></li><li><p>表级锁定</p><ul><li>特点: 实现逻辑简单，带来的系统负面影响最小，获取锁和释放锁的速度很快。可以避免死锁问题。</li><li>弊端: 出现锁定资源争用的概率最高。</li></ul></li><li><p>页级锁定</p><ul><li>特点: 锁定颗粒度介于行与表之间，处理能力介于两者之间。</li><li>弊端: 会发生死锁。<h3 id="各种锁定机制分析"><a href="#各种锁定机制分析" class="headerlink" title="各种锁定机制分析"></a>各种锁定机制分析</h3><h4 id="表级锁定"><a href="#表级锁定" class="headerlink" title="表级锁定"></a>表级锁定</h4></li></ul></li><li><p>读锁定</p><p>一个新的客户端请求在申请获取读锁定资源的时候，需要满足两个条件:</p><ol><li>请求锁定的资源当前没有被写锁定</li><li>写锁定等待队列(Pending write-lock queue)中没有更高优先级的写锁定等待</li></ol><p>如果满足了上面两个条件之后，该请求会被立即通过，并将相关的信息存入 Current read-lock queue 中，<br>而如果上面两个条件中任何一个没有满足，都会被迫进入等待队列Pending read-lock queue 中等待资源的释放。</p></li><li><p>写锁定</p><ol><li>当客户端请求写锁定的时候，MySQL 首先检查在 Current write-lock queue 是否已经有锁定相同资源的信息存在。</li><li>如果 Current write-lock queue 没有，则再检查 Pending write-lock queue。</li><li>如果在 Pending write-lock queue 中找到了，自己也需要进入等待队列并暂停自身线程等待锁定资源。</li><li>如果Pending write-lock queue 为空，则再检测 Current read-lock queue，如果有锁定存在，则同样需要 进入 Pending write-lock queue 等待。</li></ol><p>特殊情况:(当遇到这两种特殊情况的时候，写锁定会立即获得而进入Current write-lock queue 中)   </p><ol><li>请求锁定的类型为 WRITE_DELAYED;</li><li>请求锁定的类型为 WRITE_CONCURRENT_INSERT 或者是 TL_WRITE_ALLOW_WRITE ，同时 Current read lock 是 READ_NO_INSERT 的锁定类型。</li></ol></li></ul><h3 id="合理利用锁机制优化-MySQL"><a href="#合理利用锁机制优化-MySQL" class="headerlink" title="合理利用锁机制优化 MySQL"></a>合理利用锁机制优化 MySQL</h3><ul><li><p>缩短锁定时间(让Query执行时间尽可能短)<br>a) 尽量减少大的复杂 Query，将复杂 Query 分拆成几个小的 Query 分布进行<br>b) 尽可能的建立足够高效的索引，让数据检索更迅速<br>c) 尽量让 MyISAM 存储引擎的表只存放必要的信息，控制字段类型<br>d) 利用合适的机会优化 MyISAM 表数据文件  </p></li><li><p>分离能并行的操作<br>虽然MyISAM的表锁是读写互相堵塞的，但是MyISAM还有一个特性，那就是Concurrent Insert(并发插入)的特性。<br>MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项:concurrent_insert，可以设置为 0，1 或者 2。三个值的具体说明如下:<br>a) concurrent_insert=2，无论 MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据 而留下的空闲空间，都允许在数据文件尾部进行Concurrent Insert;<br>b) concurrent_insert=1，当 MyISAM 存储引擎表数据文件中间不存在空闲空间的时候，可以从文 件尾部进行Concurrent Insert;<br>c) concurrent_insert=0，无论 MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据 而留下的空闲空间，都不允许Concurrent Insert。  </p></li><li><p>合理利用读写优先级<br>默认情况下是写优先级要大于读优先级。所以，如果我们可以根据各自系统环境的差异决定读与写的优先级。<br><strong>例如:</strong> </p><ol><li>如果我们的系统是一个以读为主，而且要优先保证查询性能的话，我们可以通过设置系统参数选项 low_priority_updates=1，将写的优先级设置为比读的优先级低，即可让告诉 MySQL 尽量先处理读请求。</li><li>这里我们完全可以利用这个特性，将concurrent_insert参数设置为1，甚至如果数据被删除的可能 性很小的时候，如果对暂时性的浪费少量空间并不是特别的在乎的话，<br>将 concurrent_insert 参数设置 为 2 都可以尝试。当然，数据文件中间留有空域空间，在浪费空间的时候，还会造成在查询的时候需要读取更多的数据，所以如果删除量不是很小的话，<br>还是建议将concurrent_insert 设置为 1 更为合适。</li></ol></li><li><p>Innodb 行锁优化建议<br>Innodb 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM 的表级锁定的。<br>当系统并发量较高的 时候，Innodb 的整体性能和 MyISAM 相比就会有比较明显的优势了。但是，Innodb 的行级锁定同样也有其 脆弱的一面，当我们使用不当的时候，<br>可能会让Innodb 的整体性能表现不仅不能比MyISAM 高，甚至可能会更差。</p><ol><li>尽可能让所有的数据检索都通过索引来完成，从而避免 Innodb 因为无法通过索引键加锁而升级为表级锁定;</li><li>合理设计索引，让 Innodb 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行;</li><li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录;</li><li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度</li><li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本;</li></ol></li><li><p>Innodb减少死锁的建议</p><ol><li>类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁;</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率;</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率;</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-6.影响MySQL性能的相关因素</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-6-%E5%BD%B1%E5%93%8DMySQL%E6%80%A7%E8%83%BD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9B%A0%E7%B4%A0/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-6-%E5%BD%B1%E5%93%8DMySQL%E6%80%A7%E8%83%BD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9B%A0%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="影响MySQL-Server性能相关因素"><a href="#影响MySQL-Server性能相关因素" class="headerlink" title="影响MySQL Server性能相关因素"></a>影响MySQL Server性能相关因素</h2><h3 id="商业需求对性能的影响"><a href="#商业需求对性能的影响" class="headerlink" title="商业需求对性能的影响"></a>商业需求对性能的影响</h3><ol><li>每次产品经理们提出新的项目(或者功能需求)的时候，应该要求他们同时给出该项目的预期收益的量化指标，以备项目上先后统计评估投入产出比率;</li><li>在每次项目进行过程中，应该详细记录所有的资源投入，包括人力投入，硬件设施的投入， 以及其他任何项目相关的资源投入;</li><li>项目(或者功能需求)上线之后应该及时通过手机相关数据统计出项目的实际收益值，以便计算投入产出比率的时候使用;</li><li>技术部门应该尽可能推动设计出一个项目(或者功能需求)的投入产出比率的计算规则。在项目上线一段时间之后，通过项目实际收益的统计数据和项目的投入资源量，<br>计算出整个项目的实际投入产出值，并公布给所有参与项目的部门知晓，同时存放以备后查。</li></ol><h3 id="系统架构及实现对性能的影响"><a href="#系统架构及实现对性能的影响" class="headerlink" title="系统架构及实现对性能的影响"></a>系统架构及实现对性能的影响</h3><ul><li><p>不适合存放在数据库中的数据:</p><ol><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li></ol></li><li><p>是否合理的运用了应用层Cache机制<br>对于 Web 应用，活跃数据的数据量总是不会特别的大，有些活跃数据更是很少变化。</p></li><li><p>我们的数据层实现都是最精简的吗?<br><strong>例如: 现在要实现每个用户查看各自相册列表(假设每个列表显示10 张相片) 的时候，能够在相片名称后面显示该相片的留言数量。</strong><br>方案一:<br>1、通过“SELECT id,subject,url FROM photo WHERE user_id = ? limit 10” 得到第一页的相片相关信息;<br>2 、通过第 1 步结果集中的 10 个相片 id 循环运行十次 “ SELECT COUNT(*) FROM photo_comment WHERE photh_id = ?” 来得到每张相册的回复数量然后再瓶装展现对象。</p><p>方案二:<br>1、和上面完全一样的操作步骤;<br>2、通过程序拼装上面得到的 10 个 photo 的 id，再通过 in 查询“SELECT photo_id,count(*) FROM<br>photo_comment WHERE photo_id in (?) GROUP BY photo_id” 一次得到 10 个 photo 的所有回复数量， 再组装两个结果集得到展现对象。</p></li></ul><p>  比较如下:<br>  1、从 MySQL 执行的 SQL 数量来看 ，第一种解决方案为 11(1+10=11)条 SQL 语句，第二种解决方案 为 2 条 SQL 语句(1+1);<br>  2、从应用程序与数据库交互来看，第一种为11 次，第二种为 2 次;<br>  3、从数据库的 IO 操作来看，简单假设每次 SQL 为 1 个 IO，第一种最少 11 次 IO，第二种小于等于 11 次 IO，而且只有当数据非常之离散的情况下才会需要11 次;<br>  4、从数据库处理的查询复杂度来看，第一种为两类很简单的查询，第二种有一条 SQL 语句有 GROUP BY 操作，比第一种解决方案增加了了排序分组操作;<br>  5、从应用程序结果集处理来看，第一种11 次结果集的处理，第二中2 次结果集的处理，但是第二种 解决方案中第二词结果处理数量是第一次的10 倍;<br>  6、从应用程序数据处理来看，第二种比第一种多了一个拼装photo_id 的过程。 </p><p>  分析如下:<br>  1、由于 MySQL 对客户端每次提交的 SQL 不管是相同还是不同，都需要进行完全解析，这个动作主要 消耗的资源是数据库主机的 CPU，<br>  那么这里第一种方案和第二种方案消耗CPU 的比例是 11:2。SQL 语句的解析动作在整个 SQL 语句执行过程中的整体消耗的 CPU 比例是较多的;<br>  2、应用程序与数据库交互所消耗的资源基本上都在网络方面，同样也是11:2;<br>  3、数据库 IO 操作资源消耗为小于或者等于 1:1;<br>  4、第二种解决方案需要比第一种多消耗内存资源进行排序分组操作，由于数据量不大，多出的消耗在语句整体消耗中占用比例会比较小，大概不会超过20%，<br>  大家可以针对性测试;<br>  5、结果集处理次数也为 11:2，但是第二中解决方案第二次处理数量较大，整体来说两次的性能消耗区别不大;<br>  6、应用程序数据处理方面所多出的这个 photo_id 的拼装所消耗的资源是非常小的，甚至比应用程序与 MySQL 做一次简单的交互所消耗的资源还要少。  </p><p>  结论:<br>  1、提交的SQL会占用数据库主机CPU<br>  2、应用程序与数据库交互会占用网络<br>  3、SQL会占用IO<br>  4、字段拼装的消耗非常小</p><p>SQL并非越精简越好  </p><ol><li>不应该对表有不必要的访问</li><li>不应重复执行相同的SQL</li></ol><ul><li>数据库因架构设计而引起性能问题和资源浪费问题</li></ul><ol><li>Cache 系统的不合理利用导致 Cache 命中率低下造成数据库访问量的增加，同时也浪费了 Cache 系统的硬件资源投入;</li><li>过度依赖面向对象思想</li><li>对可扩展性的过渡追求，促使系统设计的时候将对象拆得过于离散，造成系统中大量的复杂Join 语句，而 MySQL Server 在各数据库系统中的主要优势在于处理简单逻辑的查询，这与其锁定的机制也有 较大关系;</li><li>对数据库的过渡依赖，将大量更适合存放于文件系统中的数据存入了数据库中，造成数据库资源 的浪费，影响到系统的整体性能，如各种日志信息;</li><li>过度理想化系统的用户体验，使大量非核心业务消耗过多的资源，如大量不需要实时更新的数据 做了实时统计计算。</li></ol><h3 id="Query语句对系统性能的影响"><a href="#Query语句对系统性能的影响" class="headerlink" title="Query语句对系统性能的影响"></a>Query语句对系统性能的影响</h3><ul><li>当MySQL Server的连接线程接收到Client端发送过来的SQL请求后，会经过一系列的分解Parse，进行相应的分析。</li><li>MySQL会通过查询优化器模块根据该 SQL 所设涉及到的数据表的相关统计信息进行计算分析，得出一个 MySQL认为最合理最优化的数据访问方式(执行计划)。</li><li>再根据所得到的执行计划通过调用存储引擎接口来获取相应数据，再将存储引擎返回的数据进行相关处理。</li><li>最后以 Client 端所要求的格式作为结果集返回给 Client 端的应用程序。</li></ul><p>在数据库管理软件中，最大的性能瓶颈就是磁盘IO，当我们需要从数据库中查询某个数据的时候，<br>所消耗资源的多少主要就取决于数据库以一个什么样的数据读取方式来完成我们的查询请求，也就是取决于SQL语句的执行计划。</p><h3 id="Schema设计对系统性能的影响"><a href="#Schema设计对系统性能的影响" class="headerlink" title="Schema设计对系统性能的影响"></a>Schema设计对系统性能的影响</h3><ul><li>根据需求制定表<ul><li>如: 讨论区系统需要经常访问帖子标题列表，而需要帖子和作者名应尽量放在同一表中，并且content帖子内容应单独建表。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-5.MySQL备份与恢复</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-5-MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-5-MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL备份与恢复"><a href="#MySQL备份与恢复" class="headerlink" title="MySQL备份与恢复"></a>MySQL备份与恢复</h2><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><p>逻辑备份可以说是最简单， 也是目前中小型系统最常使用的备份方式。 在MySQL 中我们 常用的逻辑备份主要就是两种，一种是将数据生成可以完全重现当前数据库中数据的<br>INSERT 语句，另外一种就是将数据通过逻辑备份软件，将我们数据库表数据以特定分隔符 进行分隔后记录在文本文件中。</p><h3 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h3><p>MyISAM 存储引擎的所有数据都存放在 MySQL 配置中所设定的“datadir”目录下。实际<br>上不管我们使用的是 MyISAM 存储引擎还是其他任何存储引擎，每一个数据库都会在 “datadir”目录下有一个文件夹(包括系统信息的数据库mysql 也是一样) 。在各个数据库 中每一个 MyISAM 存储引擎表都会有三个文件存在，分别为记录表结构元数据的“.frm”文 件，存储表数据的“.MYD”文件，以及存储索引数据的“.MYI”文件。由于 MyISAM 属于非 事务性存储引擎，所以他没有自己的日志文件。所以MyISAM 存储引擎的物理备份，除了备<br>份 MySQL 系统的共有物理文件之外，就只需要备份上面的三种文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-4.MySQL安全管理</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-4-MySQL%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-4-MySQL%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL安全管理"><a href="#MySQL安全管理" class="headerlink" title="MySQL安全管理"></a>MySQL安全管理</h2><h3 id="数据库系统安全相关因素"><a href="#数据库系统安全相关因素" class="headerlink" title="数据库系统安全相关因素"></a>数据库系统安全相关因素</h3><ul><li>外围网络</li><li>主机</li><li>数据库</li><li>代码</li></ul><h3 id="MySQL权限系统介绍"><a href="#MySQL权限系统介绍" class="headerlink" title="MySQL权限系统介绍"></a>MySQL权限系统介绍</h3><p>关权限信息主要存储在几个被称为 grant tables 的系统表中，即: mysql.User，mysql.db，mysql.Host，mysql.table_priv 和 mysql.column_priv。由于权限信息数据量比较小，而且访问又非常频繁，所以Mysql 在启 动的时候，就会将所有的权限信息都Load 到内存中保存在几个特定的结构中。<br>所以才有我 们每次手工修改了权限相关的表之后， 都需要执“行FLUSH PRIVILEGES”命令重新加载 MySQL 的权限信息。</p><ul><li>权限级别<ul><li>Global Level(全局权限控制)</li><li>Database Level(作用域为所指定整个数据库中的所有对象)</li><li>Table Level(作用范围是授权语句中所指定数据库的指定表)</li><li>Column Level(作用范围为某个表的某个列)</li><li>Routine Level(权限主要只有EXECUTE、ALTER ROUTINE两种)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-3.MySQL存储引擎简介</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-3-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-3-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL存储引擎简介"><a href="#MySQL存储引擎简介" class="headerlink" title="MySQL存储引擎简介"></a>MySQL存储引擎简介</h2><p>MyISAM是MySQL默认的存储引擎。从5.1开始，引入新概念：插件式存储引擎体系结构(MyISAM、Innodb、NDB Cluster、Maria、Falcon等)。</p><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>MyISAM支持以下三种类型的索引:</p><ol><li>B-Tree (balance tree)</li><li>R-Tree (用于存储空间和多维数据的字段索引)</li><li>Full-text (全文索引 b-tree)</li></ol><h3 id="Innodb存储引擎"><a href="#Innodb存储引擎" class="headerlink" title="Innodb存储引擎"></a>Innodb存储引擎</h3><p>特点:</p><ol><li>支持事务安装<br> 未提交读 Read uncommitted<br> 已提交读 Read committed<br> 可重复读 Repeatable read<br> 可串行化 Serializable</li><li>数据多版本读取<br>通过实现undo日志来实现数据的多版本读取。</li><li>锁定机制的改进<br>改变了MyISAM的锁机制，实现了行锁。</li><li>实现外键</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-2.MySQL架构组成</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-2-MySQL%E6%9E%B6%E6%9E%84%E7%BB%84%E6%88%90/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-2-MySQL%E6%9E%B6%E6%9E%84%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL架构组成"><a href="#MySQL架构组成" class="headerlink" title="MySQL架构组成"></a>MySQL架构组成</h2><h3 id="MySQL物理文件组成"><a href="#MySQL物理文件组成" class="headerlink" title="MySQL物理文件组成"></a>MySQL物理文件组成</h3><ul><li><p>日志文件</p><ul><li><p>错误日志:Error Log</p></li><li><p>二进制日志: Binary Log &amp; Binary Log Index<br>二进制日志，就是常说的binlog，当我们通过“–log-bin[=file_name]”打开了记录的功能之后，<br>MySQL 会将所有修改数据库数据的 query 以二进制形式记录到日志文件中。 当然，日志中并不仅限于query 语句这么简单，<br>还包括每一条query所执行的时间，所消耗的资源， 以及相关的事务信息，所以 binlog 是事务安全的。</p></li><li><p>更新日志: update Log<br>功能与binlog类似，只不过不是二进制格式，是以简单文本格式记录内容。</p></li><li><p>查询日志: query Log<br>记录MySQL中所有的query，开启后对性能有较大影响。</p></li><li><p>慢查询日志: slow query log<br>记录执行时间较长的query，简单文本格式。</p></li><li><p>Innodb的在线redo日志: innodb redo log<br>是一个事务安全的存储引擎。</p></li></ul></li><li><p>数据文件<br>多数存储引擎的数据文件都存放在和MyISAM 数据文件位置相同的目录下，但是每个数据文件的扩展名却各不一样。<br>如MyISAM 用“.MYD”作为扩展 名，Innodb 用“.ibd”，Archive 用“.arc”，CSV 用“.csv”，等等。</p><ul><li>.frm文件<br>存储与表相关的元数据信息。包括表结构的定义信息。</li><li>.MYD文件<br>专属于MyISAM存储引擎，存放MyISAM表的数据。</li><li>.MYI文件<br>专属于MyISAM存储引擎，主要存放MyISAM表的索引信息。</li><li>.ibd文件和ibdata文件<br>存放Innodb数据的文件，独享表空间的存储方式使用.ibd文件存放数据，共享表空间存放数据，则会使用ibdata文件存放。</li></ul></li><li><p>Replication相关文件</p><ul><li>master.info<br>存放在Slave端的数据目录下，存放该Slave的Master端的相关信息，包括Master的主机地址、连接用户、端口、当前日志位置、已经读取到的日志位置等信息。</li><li>relay log 和 relay log index</li><li>relay-log.info<br>类似于master.info，存放通过Slave的I/O线程写入到本地的relay log的相关信息。供Slave端的SQL线程以及某些管理操作随时能够获取当前复制的相关信息。</li></ul></li><li><p>其他文件</p><ul><li>system config file<br>MySQL的系统配置文件为my.cnf</li><li>pid file<br>是mysqld应用程序在Unix/Linux环境下的一个进程文件，存放着自己的进程id。</li><li>socket file<br>socket文件也是在Unix/Linux环境下才有的，用户在此环境下客户端连接可以不通过TCP/IP而直接使用Unix socket来连接MySQL。</li></ul></li></ul><h3 id="MySQL-Server系统架构"><a href="#MySQL-Server系统架构" class="headerlink" title="MySQL Server系统架构"></a>MySQL Server系统架构</h3><p>第一层通常叫做SQL Layer，在 MySQL 数据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断，sql 解析，执行计划优化， query cache 的处理等等;<br>第二层就是存储引擎层，我们通常叫做 Storage Engine Layer，也就是底层数据存取操作实现部分，由多种存储引擎共同组成<br><img src="https://github.com/Cynaith/Java-Daily-Interview/blob/master/MySQL/MySQL%E6%9E%B6%E6%9E%84.png" alt="MySQL架构"></p><ul><li>SQL Layer<ul><li>初始化模块</li><li>核心API</li><li>网络交互模块</li><li>Client &amp; Server交互协议模块</li><li>用户模块</li><li>访问控制模块</li><li>连接管理、连接进程和线程管理</li><li>Query解析和转发模块</li><li>Query Cache模块</li><li>Query优化器模块</li><li>表变更模块</li><li>表维护模块</li><li>状态管理模块</li><li>表管理器</li><li>日志记录模块</li><li>复制模块</li><li>存储引擎接口模块</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL性能调优-1.MySQL基本介绍</title>
      <link href="/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-1-MySQL%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/06/06/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-1-MySQL%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基本介绍"><a href="#MySQL基本介绍" class="headerlink" title="MySQL基本介绍"></a>MySQL基本介绍</h2><h3 id="功能比较"><a href="#功能比较" class="headerlink" title="功能比较"></a>功能比较</h3><p>在可编程支持方面，MySQL 和其他数据库相比还有一定的差距， 虽然最新版的MySQL 已经开始提供一些简单的可编程支持，<br>如开始支持 Procedure，Function，Trigger 等，但 是所支持的功能还比较有限， 和其他几大商用数据库管理系统相比，<br>还存在较大的不足如。Oracle 有强大的 PL/SQL，SQL Server 有 T-SQL，PostGreSQL 也有功能很完善的 PL/PGSQL 的支持。</p><h3 id="易用性比较"><a href="#易用性比较" class="headerlink" title="易用性比较"></a>易用性比较</h3><p>从系统易用性方面来比较， 每一个使用过MySQL的用户都能够明显地感觉出MySQL在这<br>方面与其他通用数据库管理系统之间的优势所在。 尤其是相对于一些大型的商业数据库理管系统如 Oracle、DB2 以及 Sybase 来说，<br>对于普通用户来说，操作的难易程度明显不处于一个级别。MySQL 一直都奉行简单易用的原则，也正是靠这一特性，<br>吸引了大量的初级数据库用户最终选择了 MySQL。也正是这一批又一批的初级用户，在经过了几年时间的成长之后，<br>很多都已经成为了高级数据库用户，而且也一直都在伴随着MySQL 成长。</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>性能方面， 一直是MySQL 引以为自豪的一个特点。 在权威的第三方评测机构多次测试较量各种数据库 TPCC 值的过程中，<br>MySQL 一直都有非常优异的表现，而且在其他所有商用的 通用数据库管理系统中，仅仅只有Oracle 数据库能够与其一较高下。<br>至于各种数据库详细 的性能数据， 我这里就不便记录， 大家完全可以通过网上第三方评测机构公布的数据了具解体细节信息。</p><p>MySQL 一直以来奉行一个原则，那就是在保证足够的稳定性的前提下，尽可能的提高自身的处理能力。 也就是说，<br>在性能和功能方面MySQL 第一考虑的要素主要还是性能，MySQL 希望自己是一个在满足客户99%的功能需求的前提下，<br>花掉剩下的大部分精力来性能努力， 而不是希望自己是成为一个比其他任何数据库的功能都要强大的数据库产品。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>关于可靠性的比较， 并没有太多详细的评测比较数据， 但是从目前业界的交流中可了以解到，<br>几大商业厂商的数据库的可靠性肯定是没有太多值得怀疑的。 但是做为开源数据管库 理系统的代表，MySQL也有非常优异的表现，<br>而并不是像有些人心中所怀疑的那样，因为不是商业厂商所提供，就会不够稳定不够健壮。从当前最火的Facebook这样大型的网站都是使用 MySQL 数据库，<br>就可以看出，MySQL在稳定可靠性方面，并不会比我们的商业厂商的产品有太多逊色。而且排在全球前10位的大型网站里面，<br>大部分都有部分业务是运行在MySQL 数据库环境上，如 Yahoo，Google 等。</p><h3 id="MySQL适用场景"><a href="#MySQL适用场景" class="headerlink" title="MySQL适用场景"></a>MySQL适用场景</h3><ul><li><p>Web 网站系统</p><ul><li>Web 站点，是 MySQL 最大的客户群，也是MySQL 发展史上最为重要的支撑力量，这一点<br>在最开始的 MySQL Server 简介部分就已经说明过。<br>MySQL 之所以能成为 Web 站点开发者们最青睐的数据库管理系统， 是因为MySQL 数据库 的安装配置都非常简单，使用过程中的维护也不像很多大型商业数据库管理系统那么复杂， 而且性能出色。还有一个非常重要的原因就是MySQL 是开放源代码的，完全可以免费使用。</li></ul></li><li><p>日志记录系统</p><ul><li>MySQL 数据库的插入和查询性能都非常的高效，如果设计地较好，在使用 MyISAM 存储<br>引擎的时候， 两者可以做到互不锁定， 达到很高的并发性能。 所以， 对需要大量的插入和查询日志记录的系统来说，MySQL 是非常不错的选择。 比如处理用户的登录日志， 操作日志等，都是非常适合的应用场景。</li></ul></li><li><p>数据仓库系统</p><ul><li>随着现在数据仓库数据量的飞速增长， 我们需要的存储空间越来越大。 数据量的不增断长，<br>使数据的统计分析变得越来越低效，也越来越困难。 怎么办?这里有几个主要的解决思路， 一个是采用昂贵的高性能主机以提高计算性能，<br>用高端存储设备提高I/O 性能，效果理想，但是成本非常高;第二个就是通过将数据复制到多台使用大容量硬盘的廉价pc server 上，<br>以提高整体计算性能和I/O 能力， 效果尚可， 存储空间有一定限制， 成本低廉; 第三个，通过将数据水平拆分，<br>使用多台廉价的pc server 和本地磁盘来存放数据， 每台机器上面都 只有所有数据的一部分，解决了数据量的问题，所有pc server一起并行计算，<br>也解决了计算能力问题， 通过中间代理程序调配各台机器的运算任务， 既可以解决计算性能问题又可以解决 I/O 性能问题，成本也很低廉。<br>在上面的三个方案中，第二和第三个的实现，MySQL都有较大的优势。 通过MySQL的简单复制功能， 可以很好的将数据从一台主机复制到另外一台，<br>不仅仅在局域网内可以复制， 在广域网同样可以。 当然，很多人可能会说，其他的数据库同样也可以做到， 不是只有 MySQL 有这样的功能。<br>确实， 很多数据库同样能做到， 但是MySQL 是免费的，其他数据库大多都是按照主机数量或者 cpu 数量来收费，<br>当我们使用大量的 pc server 的时候，license 费用相当惊人。第一个方案，基本上所有数据库系统都能够实现，<br>但是其高昂的成本并不是每一个公司都能够承担的。</li></ul></li><li><p>嵌入式系统</p><ul><li>嵌入式环境对软件系统最大的限制是硬件资源非常有限， 在嵌入式环境下运行的软系件统，必须是轻量级低消耗的软件。<br>MySQL 在资源的使用方面的伸缩性非常大，可以在资源非常充裕的环境下运行，也可以在资源非常少的环境下正常运行。<br>它对于嵌入式环境来说，是一种非常合适的数据库系统， 而且 MySQL 有专门针对于嵌入式环境的版本。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-7-确保Web安全的HTTPS</title>
      <link href="/2020/05/26/%E5%9B%BE%E8%A7%A3HTTP-%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/"/>
      <url>/2020/05/26/%E5%9B%BE%E8%A7%A3HTTP-%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h2><ul><li><p>通信使用明文(不加密)，内容可能会被窃听</p><ul><li><p>如何加密处理防止被窃听？</p><ul><li><p>将通信加密<br>HTTP 协议中没有加密机制，但可以通过和 SSL(Secure Socket Layer，安全套接层)或<br>TLS(Transport Layer Security，安全层传输协议)的组合使用，加密 HTTP 的通信内容。</p><p>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。<br>与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure，超文本传输安全协议)或 HTTP over SSL。</p></li><li><p>将内容加密<br>客户端需要对HTTP报文进行加密处理在发送请求，但是内容仍有被篡改的风险。</p></li></ul></li></ul></li><li><p>不验证通信方的身份，因此有可能遭遇伪装</p><ul><li>任何人都可发起请求，会存在以下隐患<ul><li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li><li>无法确定响应返回到的客户端是否是按真实意图接收响 应的那个客户端。有可能是已伪装的客户端。</li><li>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。</li><li>无法判定请求是来自何方、出自谁手。</li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service，拒绝服务攻击)。</li></ul></li><li>查明对手的证书<ul><li>使用SSL可以确定通信方</li></ul></li></ul></li><li><p>无法证明报文的完整性，所以有可能已遭篡改</p><ul><li>接收到的内容可能有误<br>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(MITM)</li><li>如何防止篡改<br>常用的是 MD5 和 SHA-1等散列值校验的方法，用来确认文件的数字签名方法。(可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。)</li></ul><p>为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。</p></li></ul><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h2><p>HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替。</p><p>通常，HTTP直接和TCP通信，当使用SSL时，则变为先和SSL通信，再由SSL和TCP通信。</p><ul><li><p>相互交换密钥的公开密钥加密技术<br>SSL 采用一种叫做公开密钥加密(Public-key cryptography)的加密处理方式。</p><ul><li><p>共享密钥加密的困境<br>加密和解密用同一个密钥的方式称为共享密钥加密，也叫做对称密钥加密。但发送密钥也有被窃听的风险。</p></li><li><p>使用两把密钥的公开密钥加密<br>发送密文一方使用公开密钥进行加密处理，对方收到信息后，在用自己的私有密钥进行解密。(解密过程就是对离散对数进行求值)</p></li><li><p>HTTPS采用混合加密机制<br>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p><ol><li>使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥</li><li>确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信</li></ol></li></ul></li><li><p>证明公开密钥正确性的证书  </p><blockquote><p>防止公开密钥在传输途中，被攻击者替换。</p></blockquote></li></ul><p>为了解决上述问题，可以使用由数字证书认证机构和其相关机关颁发的公开密钥证书。</p>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-6-HTTP首部</title>
      <link href="/2020/05/26/%E5%9B%BE%E8%A7%A3HTTP-HTTP%E9%A6%96%E9%83%A8/"/>
      <url>/2020/05/26/%E5%9B%BE%E8%A7%A3HTTP-HTTP%E9%A6%96%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h2><p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。</p><p>报文首部由几个字段构成</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>在请求中，HTTP报文由方法、URI、HTTP版本(前三个为请求行)、HTTP首部字段等部分构成。</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p>在响应中，HTTP报文由HTTP版本、状态码(数字和原因短语)、HTTP首部字段构成</p><h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><ul><li><p>结构<br>首部字段名:字段值</p><blockquote><p>若HTTP首部字段重复，则根据浏览器内部逻辑处理。</p></blockquote></li><li><p>4中HTTP首部字段类型</p><ul><li>通用首部字段<br>请求报文和响应报文两方都会使用的首部</li><li>请求首部字段<br>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>响应首部字段<br>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li><li>实体首部字段<br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li></ul></li><li><p>HTTP/1.1首部字段一览</p><ul><li>通用首部字段<ul><li>Cache-Control 控制缓存的行为</li><li>Connection 逐跳首部、连接的管理</li><li>Date 创建报文的日期与时间</li><li>Pragma 报文指令</li><li>Trailer 报文末端的首部一览</li><li>Transfer-Encoding 指定报文主体的传输编码方式</li><li>Upgrade 升级为其他协议</li><li>Via 代理服务器相关信息</li><li>Warning 错误通知</li></ul></li><li>请求首部字段<ul><li>Accept 用户代理可处理的媒体类型</li><li>Accept-Charset 优先的字符集</li><li>Accept-Encoding 优先的内容编码</li><li>Accept-Language 优先的语言(自然语言)</li><li>Authorization Web认证信息</li><li>Expect 期待服务器的特定行为</li><li>From 用户的电子邮箱地址</li><li>Host 请求资源所在服务器</li><li>If-Match 比较实体标记(ETag)</li><li>If-Modified-Since 比较资源的更新时间</li><li>If-None-Match 比较实体标记(与 If-Match 相反)</li><li>If-Range 资源未更新时发送实体 Byte 的范围请求</li><li>If-Unmodified-Since 比较资源的更新时间(与If-Modified-Since相反)</li><li>Max-Forwards 最大传输逐跳数</li><li>Proxy-Authorization 代理服务器要求客户端的认证信息</li><li>Range 实体的字节范围请求</li><li>Referer 对请求中 URI 的原始获取方</li><li>TE 传输编码的优先级</li><li>User-Agent HTTP 客户端程序的信息</li></ul></li><li>响应首部字段<ul><li>Accept-Ranges 是否接受字节范围请求</li><li>Age 推算资源创建经过时间</li><li>ETag 资源的匹配信息</li><li>Location 令客户端重定向至指定URI</li><li>Proxy-Authenticate 代理服务器对客户端的认证信息</li><li>Retry-After 对再次发起请求的时机要求</li><li>Server HTTP服务器的安装信息</li><li>Vary 代理服务器缓存的管理信息</li><li>WWW-Authenticate 服务器对客户端的认证信息</li></ul></li><li>实体首部字段<ul><li>Allow 资源可支持的HTTP方法</li><li>Content-Encoding 实体主体适用的编码方式</li><li>Content-Language 实体主体的自然语言</li><li>Content-Length 实体主体的大小(单位:字节)</li><li>Content-Location 替代对应资源的URI</li><li>Content-MD5 实体主体的报文摘要</li><li>Content-Range 实体主体的位置范围</li><li>Content-Type 实体主体的媒体类型</li><li>Expires 实体主体过期的日期时间</li><li>Last-Modified 资源的最后修改日期时间</li></ul></li></ul></li><li><p>非HTTP/1.1首部字段<br>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p></li><li><p>End-to-end 首部和 Hop-by-hop 首部</p><ul><li>端到端首部(End-to-end Header)<br>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</li><li>逐跳首部(Hop-by-hop Header)<br>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</li><li>HTTP/1.1中的逐跳首部字段(除此之外都属于端到端首部)<ul><li>Conne ction</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade<h2 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h2></li></ul></li></ul></li><li><p>Cache-Control</p><h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2></li></ul><h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><h2 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h2><ul><li>Set-Cookie <ul><li>说明:开始状态管理所使用的Cookie信息 </li><li>首部类型:响应首部字段</li><li>当服务器准备开始管理客户端状态时，会事先告知各种信息，包含的字段有:<ul><li><code>NAME = VALUE</code> 赋予Cookie的名称和值</li><li><code>expires = DATE</code> Cookie的有效期(若不指明则默认到浏览器关闭前为止)<br>一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法。(但可通过覆盖间接删除)</li><li><code>path = PATH</code> 将服务器上的文件目录作为Cookie的适用对象(若不指定则默认文档所在的文件目录)</li><li><code>domain = 域名</code> 作为Cookie适用对象的域名(若不指定则为创建Cookie的服务器的域名)<br>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。</li><li><code>Secure</code> 仅在HTTPS安全通信时才会发送Cookie</li><li><code>HttpOnly</code> 使Cookie不能被JavaScript脚本访问</li></ul></li></ul></li><li>Cookie <ul><li>说明:服务器接收到的Cookie信息</li><li>首部类型:请求首部字段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-5-与HTTP协作的Web服务器</title>
      <link href="/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="通信转发程序-代理、网关、隧道"><a href="#通信转发程序-代理、网关、隧道" class="headerlink" title="通信转发程序: 代理、网关、隧道"></a>通信转发程序: 代理、网关、隧道</h2><blockquote><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。他们可以配合服务器工作。</p></blockquote><ul><li><p>代理<br>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色，<br>接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p>代理服务器的基本行为就是接收客户端发送的请求后，转发给其他服务器。<br>每次通过代理服务器转发请求时，会追加写入Via首部信息。例如请求经过proxy1、proxy2:<code>Via:proxy2,proxy1</code>。</p><ul><li><p><strong>使用理由</strong> :利用缓存技术减少网络带宽的流量、组织内部针对特定网络的访问控制、获取访问日志。</p></li><li><p><strong>使用方法</strong> :一种是是否使用缓存，另一种是是否会修改报文。</p></li><li><p><strong>缓存代理</strong> :代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本 (缓存)保存在代理服务器上。<br>当代理再次收到相同的资源请求时，就不用从源服务器那里获取资源(会向源服务器确认缓存资源的有效性)，而是将之前缓存的资源作为响应返回。</p></li><li><p><strong>透明代理</strong> :转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 (Transparent Proxy)。反之，对报文内容进行加工的代理被称为非透明代理。</p></li></ul></li><li><p>网关<br>网关可以由HTTP请求转化为其他协议通信。利用网关可以加密客户端与网关之间的通信线路。</p><p>例如，网关可以连接数据库，使用SQL语句查询数据。另外在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p></li><li><p>隧道<br>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。<br>请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p></li></ul><h2 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h2><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件 (Temporary Internet File)。</p><p>和缓存服务器相同的一点是，当判定缓存过期后，会向源服务 器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新 资源。</p>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-4-返回结果的HTTP状态码</title>
      <link href="/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h2><p>常见的状态码</p><ul><li><p>1xx 提示成功，表示目前是协议处理的中间状态</p></li><li><p>2xx 成功，报文已经收到并被正确处理</p></li><li><p>3xx 重定向，资源位置发生变动，需要客户端重新发送请求</p></li><li><p>4xx 客户端错误，请求报文有误，服务器无法处理</p></li><li><p>5xx 服务器错误，服务器在处理请求时内部发生了错误</p></li><li><p>2xx 成功</p><ul><li>200 OK</li><li>204 No Content<br>表示服务器接受的请求已经成功处理，但是响应报文中不含实体的主体部分。</li><li>206 Partial Content<br>表示客户端进行了范围请求，并且服务器成功执行了GET请求。<br>响应报文中包含由Content-Range指定范围的实体内容。</li></ul></li><li><p>3xx 重定向</p><ul><li><p>301 Moved Permanently 永久性重定向<br>表示请求的资源已被分配给了新的URI，</p></li><li><p>302 Found 临时性重定向<br>状态码表示请求的资源已被分配了新的URI，希望用户能使用新的URI访问。</p></li><li><p>303 See Other<br>表示请求对应的资源存在着另一个URI，应使用<strong>GET</strong>方法定向获取请求的资源</p></li><li><p>304 Not Modified<br>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304返回时不包含任何响应的主体部分。  </p><blockquote><p>什么是附带条件？</p><p>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。</p></blockquote></li><li><p>307 Temporary Redirect 临时重定向<br>和302有着相同的含义，但是 307禁止POST变换成GET</p></li></ul></li><li><p>4xx 客户端错误</p><ul><li><p>400 Bad Request<br>请求报文中存在语法错误</p></li><li><p>401 Unauthorized<br>表示发送的请求需要有通过HTTP认证的认证信息。若之前进行过请求，则表示用户认证失败。</p><p>返回含有 401 的响应必须包含一个适用于被请求资源的 <code>WWW- Authenticate</code> 首部用以质询(challenge)用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。</p></li><li><p>403 Forbidden<br>表示访问被服务器拒绝，服务端可以在实体的主体部分对原因进行描述。</p></li><li><p>404 Not Found</p></li></ul></li><li><p>5xx 服务器错误</p><ul><li>500 Internal Server Error<br>表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li><li>503 Service Unavailable<br>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-3-HTTP报文内的HTTP信息</title>
      <link href="/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><blockquote><p>用于HTTP协议交互的信息被称为HTTP报文。HTTP报文是由多行(用CR+LF坐换行符)数据构成的字符串文本。</p><p>请求端的HTTP报文叫做 <strong>请求报文</strong></p><p>响应端的叫做 <strong>响应报文</strong> </p></blockquote><p>HTTP报文大致分为报文首部和报文主体两块(由空行划分)，通常并不一定要有报文主体。</p><ul><li>请求报文结构<ul><li>报文首部<ul><li>请求行<br>包含用于请求的方法，请求URI和HTTP版本 <code>GET/HTTP/1.1</code></li><li>请求首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li><li>空行(CR+LF)</li><li>报文主体</li></ul></li><li>响应报文结构<ul><li>报文首部<ul><li>状态行<br>包含表明响应结果的状态码，原因短语和HTTP版本 <code>HTTP/1.1 200 OK</code></li><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li><li>空行(CR+LF)</li><li>报文主体</li></ul></li></ul><h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><blockquote><p>HTTP在传输数据时进行编码，可以有效地处理大量的访问请求。</p></blockquote><ul><li><p>报文主体和实体主体</p><ul><li>报文(message)<br>是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输。</li><li>实体(entity)<br>作为请求或响应的有效载荷数据被传输，内容由实体首部和实体主体组成。</li></ul><blockquote><p>HTTP报文的主体用于传输请求或响应的实体主体。</p><p>通常报文主体等于实体主体，只有在传输中进行编码操作时，实体主体内容发生改变，才导致它和报文主体产生差异。</p></blockquote></li><li><p>压缩传输的内容编码</p><blockquote><p>内容编码类似压缩文件，常用的内容编码有 gzip、compress、deflate、identity</p></blockquote><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p></li><li><p>分割发送的分块传输编码</p><blockquote><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步加载页面。这种功能叫做分块传输编码。</p></blockquote><p>分块传输编码会将实体主体分成多个部分，每一块用16进制来标记块的大小，而实体主体最后一块会使用”0(CR+LF)”来标记。</p><p>客户端负责解码，恢复到编码前的实体主体。</p></li></ul><h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><blockquote><p>如果下载过程中遇到网络中断的情况，那就必须重头开始，为了解决上述问题，需要一种可恢复的机制。即能从之前下载中断处恢复下载。</p></blockquote><p>  执行范围请求时，会用到首部字段Range来指定资源的byte范围<br>  <code>Range: bytes = 5001-10000</code> 5001-10000字节<br>  <code>Range: bytes = 5001-</code> 从5001字节之后全部的<br>  <code>Range: bytes = -3000,5000-7000</code> 从头开始3000字节和5000-7000<br>  对于此类请求，响应会返回状态码为206 Partial Content的响应报文。 对于多重范围的请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。</p><p>  注: 如果服务端无法响应范围请求，则会返回状态码 200 OK 和完整的实体请求。</p>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-2-简单的HTTP协议</title>
      <link href="/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h2><ul><li>请求报文<br>请求方法、请求URI、协议版本、可选的请求首部字段、内容实体。  </li><li>响应报文<br>协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段、实体主体。</li></ul><h2 id="HTTP是不保存状态的协议-无状态协议"><a href="#HTTP是不保存状态的协议-无状态协议" class="headerlink" title="HTTP是不保存状态的协议(无状态协议)"></a>HTTP是不保存状态的协议(无状态协议)</h2><blockquote><p>在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理</p></blockquote><p>每当有对应的新响应产生，协议本身并不保留之前一切的请求或响应报文的信息。<br>这是为了更快地处理大量事务，确保协议的可伸缩性。</p><p>但是随着Web发展，用户需要在网站保存登陆状态。<br>HTTP/1.1虽然是无状态协议，但引用Cookie技术后，就可以管理状态。</p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul><li><p>GET 获取资源</p></li><li><p>POST 传输实体主体</p></li><li><p>PUT 传输文件</p><blockquote><p>HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此一般Web网站不使用该方法。</p></blockquote></li><li><p>HEAD 获得报文首部</p></li></ul><p>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p><ul><li><p>DELETE 删除文件</p><blockquote><p>一般也不使用</p></blockquote></li><li><p>OPTIONS 询问支持的方法</p></li><li><p>TRACE 追踪路径</p><blockquote><p>易引发XST(跨站追踪)攻击，所以用不到。</p></blockquote></li><li><p>CONNECT 要求用隧道协议连接代理</p></li></ul><p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。<br>主要使用 SSL(Secure Sockets Layer，安全套接 层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输。</p><p>格式:<code>CONNECT 代理服务器名:端口号 HTTP版本</code></p><h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>为了解决多次通信的开销问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接(HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse)的方法。</p><p>特点:只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p><p>注:在HTTP/1.1中，所有连接默认是持久连接</p><p>附:管线化(pipelining)技术比持久连接还要快。</p>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP-1-了解Web及网络基础</title>
      <link href="/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/25/%E5%9B%BE%E8%A7%A3HTTP-%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h2><blockquote><p>通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集</p></blockquote><ul><li>TCP/IP协议族</li></ul><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。我们把这种规则称为协议(protocol)。</p><blockquote><p>TCP/IP是互联网相关的各类协议族的总称(IP、PPPoE、DNS、UDP、FTP、SNMP、HTTP、FDDI、TCP、ICMP、IEEE 802.3)</p></blockquote><ul><li>TCP/IP的分层管理</li></ul><p>TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层：<strong>应用层、传输层、网络层和数据链路层</strong> 。</p><blockquote><p>层次化后，处于引用层上的应用可以只考虑分派给自己的任务，不需要弄清对方在那个地方和传输路线等问题。</p></blockquote><ul><li>应用层</li></ul><p>应用层决定了向用户提供应用服务时通信的活动</p><blockquote><p>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol，文件传输协议)和 DNS(Domain Name System，域 名系统)服务就是其中两类。</p><p>HTTP 协议也处于该层。</p></blockquote><ul><li>传输层</li></ul><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<br>传输层有两个性质不同的协议：TCP(Transmission Control Protocol，传输控制协议)和 UDP(User Data Protocol，用户数据报协议)。</p><ul><li>网络层</li></ul><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<br>该层规定了通过怎样的路径(所谓的传输路线)到达对方计算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><ul><li>链路层</li></ul><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card，网络适配器，即网卡)，<br>及光纤等物理可见部分(还包括连接器等一切传输媒介)。硬件上的范畴均在链路层的作用范围之内。</p><ul><li>TCP/IP通信传输流</li></ul><ol><li>客户端由应用层发出一个HTTP请求。</li><li>接着传输层把应用层处收到的数据进行分割，并在各个报文上打上标记序号及端口号转发给网络层。(并在此层打上TCP首部信息)</li><li>网络层增加作为通信目的地的MAC地址后转发给链路层。(并在此层打上IP首部信息)</li><li>接收端的服务器在链路层接收到数据。(在客户端打上以太网首部信息，在接收端把以太网首部信息消去)</li><li>按序向上传输，直至应用层，才能算真正接收到由客户端发过来的HTTP请求.(每经过一层时会把对应的首部消去)</li></ol><h2 id="与HTTP关系密切的IP、TCP、DNS"><a href="#与HTTP关系密切的IP、TCP、DNS" class="headerlink" title="与HTTP关系密切的IP、TCP、DNS"></a>与HTTP关系密切的IP、TCP、DNS</h2><ul><li><strong>负责传输的IP协议</strong><blockquote><p>IP网际协议属于网络层。</p></blockquote></li></ul><p>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址(Media Access Control Address)。<br>IP地址指明节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可以变换，但MAC地址基本不会改变。<br>使用ARP协议凭借MAC地址进行通信<br>IP之间的通信依赖MAC地址，在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议。</p><blockquote><p>ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p></blockquote><ul><li><strong>确保可靠的TCP协议</strong></li></ul><blockquote><p>TCP位于传输层，提供可靠的字节流服务。</p><blockquote><p>什么是字节流服务？<br/><br>为了方便传输，将大块的数据分割成以报文段(segment)为单位的数据包进行管理。</p></blockquote><blockquote><p>什么是可靠的传输服务？<br/><br>能够把数据准确可靠地传给对方。</p></blockquote><p>TCP协议为了更容易传送大数据才把数据分割，而TCP协议能够确认数据最终是否送达到对方。</p></blockquote><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。握手过程中使用了TCP的标志–SYN和ACK</p><ol><li>发送端首先发送一个带SYN标志的数据包给对方。</li><li>接收端收到后，回传一个带有SYN/ACK标志的数据包以传达确认信息。</li><li>发送端再回传一个带ACK标志的包，代表握手结束。</li></ol><ul><li><strong>负责域名解析的DNS服务</strong> <blockquote><p>和HTTP协议一样，位于应用层</p></blockquote></li></ul><p>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。     </p><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul><li>URI 统一资源标识符(Uniform Resource Identifier)<blockquote><p>Uniform 规定统一格式可方便处理多种不同类型的资源。</p></blockquote></li></ul><blockquote><p>Resource 资源的定义是”可标识的任何东西”。除了文档文件、图像或服务(例 如当天的天气预报)等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p></blockquote><blockquote><p>Identifier 表示可标识的对象</p></blockquote><ul><li><p>URL用字符串标识某一互联网资源，而URL表示资源的地点(互联网上所处的位置)。URL是URI的子集。</p></li><li><p>URI格式</p></li></ul><p><code>http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</code><br>http:// 协议方案名<br>user:pass 登陆信息(认证)<br><a href="http://www.example.jp" target="_blank" rel="noopener">www.example.jp</a> 服务器地址<br>80 服务器端口号<br>dir/index.htm 带层次的文件路径<br>uid=1 查询字符串<br>ch1 片段标识符  </p>]]></content>
      
      
      <categories>
          
          <category> 图解HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis算法-scan</title>
      <link href="/2020/05/02/Redis%E7%AE%97%E6%B3%95-scan/"/>
      <url>/2020/05/02/Redis%E7%AE%97%E6%B3%95-scan/</url>
      
        <content type="html"><![CDATA[<ul><li>Redis算法</li><li>数据快速查询算法</li><li>scan</li></ul><h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><hr><ul><li><p>如何从海量的key中找出满足特定前缀的key列表?</p><ul><li><code>keys *</code> : 获取全部key</li><li><code>keys sth*</code> : 获取前缀为sth的key</li><li><code>keys sth*sth</code> : 获取前缀和后缀为sth的key</li><li>缺点:<br><br>1. 没有offset、limit参数<br><br>2. 复杂度为O(n)</li></ul></li><li><p>scan的特点</p><ul><li>复杂度虽然也是O(n),但它是通过游标分步进行的,不会堵塞线程。</li><li>提供limit参数,可以控制每次返回结果的最大条数</li><li>同keys一样,它也提供模式匹配功能。</li><li>服务器不需要为游标保存状态,游标唯一状态就是scan返回给客户端的游标整数。</li><li><font color= #ff4911>返回的数据可能会有重复,需要客户端去重</font></li><li>遍历过程中如果有数据修改,改动后的数据能不能遍历是不确定的。</li><li>单次返回的结果是空的并不意味着遍历结束,而要看返回的游标值是否为零。</li></ul></li></ul><hr><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>scan提供三个参数<ul><li><strong>cursor:</strong> 游标位置,第一次遍历时cursor为0,然后将返回的游标作为下一次遍历的cursor,一直到返回的cursor为0</li><li><strong>key正则表模式</strong></li><li><strong>遍历的limit hint:</strong> 一次遍历多少次</li></ul></li><li>Demo  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match key999* count 3000</span><br><span class="line"></span><br><span class="line">1) "1746"</span><br><span class="line">2) 1) "key9996"</span><br><span class="line">     2) "key999"</span><br><span class="line">     3) "key9990"</span><br><span class="line">127.0.0.1:6379&gt; scan 1746 match key999* count 3000</span><br><span class="line"></span><br><span class="line">1) "9753"</span><br><span class="line">2) 1) "key9997"</span><br><span class="line">     2) "key9999"</span><br><span class="line">     3) "key9991"</span><br><span class="line">127.0.0.1:6379&gt; scan 9753 match key999* count 3000</span><br><span class="line"></span><br><span class="line">1) "5223"</span><br><span class="line">2) 1) "key9995"</span><br><span class="line">     2) "key9998"</span><br><span class="line">     3) "key9994"</span><br><span class="line">     4) "key9992"</span><br><span class="line">127.0.0.1:6379&gt; scan 5223 match key999* count 3000</span><br><span class="line"></span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "key9993"</span><br></pre></td></tr></table></figure></li><li>更多scan命令<ul><li><code>zscan</code>遍历zset集合元素</li><li><code>hscan</code>遍历hash字典元素</li><li><code>sscan</code>遍历set集合元素</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis算法-GeoHash</title>
      <link href="/2020/05/02/Redis%E7%AE%97%E6%B3%95-GeoHash/"/>
      <url>/2020/05/02/Redis%E7%AE%97%E6%B3%95-GeoHash/</url>
      
        <content type="html"><![CDATA[<h3 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h3><hr><ul><li>什么是GeoHash算法?<ul><li>通用的地理位置距离排序算法</li></ul></li><li>原理<ul><li>GeoHash算法将二维的经纬度数据映射到一维的整数,这样所有的元素都将挂载到一条线上,距离靠近的二维坐标映射到一维后的点之间距离也会很接近。</li></ul></li></ul><hr><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>增加<ul><li>geoadd指令携带集合名称以及<font color=#ff4911>多个</font>经纬度名称三元组</li><li>Demo  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">        127.0.0.1:6379 &gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">        </span><br><span class="line">        (integer) 1</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379 &gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">        </span><br><span class="line">        (integer) 1</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379 &gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">        </span><br><span class="line">        (integer) 1</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379 &gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">        </span><br><span class="line">        (integer) 2</span><br><span class="line">        ```  </span><br><span class="line">* 距离</span><br><span class="line">    * geolist指令可以用来计算两个元素之间的距离,携带集合名称、两个名称和距离单位  </span><br><span class="line">    * Demo</span><br><span class="line">        ```shell script</span><br><span class="line">        127.0.0.1:6379 &gt; geodist company juejin ireader km</span><br><span class="line">        </span><br><span class="line">        "10.5501"</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">        </span><br><span class="line">        "1.3878"</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">        </span><br><span class="line">        "24.2739"</span><br><span class="line">        </span><br><span class="line">        127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">        </span><br><span class="line">        "0.0000"</span><br><span class="line">        ``` </span><br><span class="line">* 获取元素位置</span><br><span class="line">    * geopos指令可以获取集合中任意元素的经纬度坐标,可以一次获取多个。</span><br><span class="line">    * Demo</span><br><span class="line">        ```shell script</span><br><span class="line">        127.0.0.1:6379 &gt; geopos company juejin</span><br><span class="line"></span><br><span class="line">        1) 1) "116.48104995489120483"</span><br><span class="line">             2) "39.99679348858259686"</span><br><span class="line">           </span><br><span class="line">        127.0.0.1:6379 &gt; geopos company ireader</span><br><span class="line">        </span><br><span class="line">        1) 1) "116.5142020583152771"</span><br><span class="line">             2) "39.90540918662494363"</span><br><span class="line">             </span><br><span class="line">        127.0.0.1:6379 &gt; geopos company meituan xiaomi</span><br><span class="line">        </span><br><span class="line">        1) 1) "116.48903220891952515"</span><br><span class="line">             2) "40.00766997707732031"</span><br><span class="line">        2) 1) "116.33425265550613403"</span><br><span class="line">             2) "40.02740024658161389"</span><br><span class="line">        ```      </span><br><span class="line">* 获取元素hash值</span><br><span class="line">    * GeoHash可以获取元素的经纬度编码字符串,上面已经提到,他是base32编码。</span><br><span class="line">    你可以使用这个编码值去[http://geohash.org/$&#123;hash&#125;](http://geohash.org)上进行定位     </span><br><span class="line">    * Demo </span><br><span class="line">        ```shell script</span><br><span class="line">            127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">      </span><br><span class="line">            1) "wx4g52e1ce0"</span><br></pre></td></tr></table></figure>  <a href="http://geohash.org/wx4g52e1ce0" target="_blank" rel="noopener">http://geohash.org/wx4g52e1ce0</a></li></ul></li><li>附近的member<ul><li><code>georadiusbymember</code>指令是最为关键的指令之一,它可以用来查询指定元素附近的其他元素。</li><li>Demo  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line"></span><br><span class="line">1) "ireader"</span><br><span class="line">2) "juejin"</span><br><span class="line">3) "meituan"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379 &gt; georadiusbymember company ireader 20 km count 3 desc</span><br><span class="line"></span><br><span class="line">1) "jd"</span><br><span class="line">2) "meituan"</span><br><span class="line">3) "juejin"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">三个可选参数 withcoord、withdist、withhash用来携带附加参数</span></span><br><span class="line">127.0.0.1:6379 &gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc</span><br><span class="line"></span><br><span class="line">1) 1) "ireader"</span><br><span class="line">     2) "0.0000"</span><br><span class="line">     3) (integer) 4069886008361398</span><br><span class="line">     4) 1) "116.5142020583152771"</span><br><span class="line">          2) "39.90540918662494363"</span><br><span class="line">2) 1) "juejin"</span><br><span class="line">     2) "10.5501"</span><br><span class="line">     3) (integer) 4069887154388167</span><br><span class="line">     4) 1) "116.48104995489120483"</span><br><span class="line">          2) "39.99679348858259686"</span><br><span class="line">3) 1) "meituan"</span><br><span class="line">     2) "11.5748"</span><br><span class="line">     3) (integer) 4069887179083478</span><br><span class="line">     4) 1) "116.48903220891952515"</span><br><span class="line">          2) "40.00766997707732031"</span><br></pre></td></tr></table></figure><ul><li>除了georadiusbymember,Redis还提供了根据坐标查询附近元素的指令<code>georadius</code></li><li>Demo  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius company 116.514 39.905 20 km count 3 desc</span><br><span class="line"></span><br><span class="line">1) "jd"</span><br><span class="line">2) "meituan"</span><br><span class="line">3) "juejin"</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><ul><li>GeoHash只是一个普通的SortedSet,使用<code>zrem</code>指令可删除元素</li><li>建议Geo数据使用单独的实例部署,不使用集群环境</li><li>数据量过大应拆分Geo数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis算法 </tag>
            
            <tag> 坐标定位算法 </tag>
            
            <tag> GeoHash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-布隆过滤器</title>
      <link href="/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><hr><h5 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h5><ul><li>黑客不断请求缓存和数据库中不存在的数据</li></ul><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>当通过某一个key查数据时,如果对应的数据库和缓存中都不存在,则在缓存中设置此key为null,并设定一个失效时间。</li></ul><ul><li>布隆过滤器<ul><li><strong>理解:</strong> 长度为n的二进制向量,通过一系列随机映射函数(eg：多个Hash)将数据映射进布隆过滤器中。<br></li><li><strong>优点:</strong> 存放的不是完整的数据,占用内存很少。新增、查询速度够快。<br></li><li><strong>缺点:</strong> 随着数据量的增大,误判率会随之增加,只能判断数据一定不存在,不能判断数据一定存在。</li><li><strong>guava实现布隆过滤器:</strong> <br><br><br>  导入guava依赖  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>   测试Demo:   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;<span class="comment">//预计要插入多少数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;<span class="comment">//期望的误判率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000000</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//mightContain(i)判断i是否在布隆过滤器中</span></span><br><span class="line">        <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(i + <span class="string">"误判了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"总共的误判数:"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>爬虫系统的URL去重</li><li>Hbase、Cassandra、LevelDB、RocksDB内部都有布隆结构</li><li>邮箱系统的垃圾邮件过滤</li></ul><hr><p> refer to <a href="https://www.cnblogs.com/zhanggguoqi/p/10571225.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhanggguoqi/p/10571225.html</a><br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/CodeBear/p/10911177.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeBear/p/10911177.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据结构 </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> 缓存穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-HyperLogLog</title>
      <link href="/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-HyperLogLog/"/>
      <url>/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-HyperLogLog/</url>
      
        <content type="html"><![CDATA[<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><hr><ul><li>什么时候需要用到HyperLogLog?<ul><li>统计UV(去重不精确的计数业务)</li></ul></li></ul><hr><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li>HyperLogLog提供了两个指令<code>pfadd</code>(增加计数)、<code>pfcount</code>(获取计数)。<br>(pf是HyperLogLog数据结构的发明人Philippe Flajolet)<ul><li>Demo  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; pfadd codehole user1</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379 &gt; pfadd codehole user2</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379 &gt; pfcount codehole</span><br><span class="line"></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>pfmerge:</strong> 用于将多个pf计数值累加在一起形成一个新的pf值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据结构 </tag>
            
            <tag> HyperLogLog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-跳跃链表</title>
      <link href="/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Java操作有序集合SortedSet"><a href="#Java操作有序集合SortedSet" class="headerlink" title="Java操作有序集合SortedSet"></a>Java操作有序集合SortedSet</h2><ul><li><strong>插入score和member到有序集合key中:</strong> <code>jedis.zadd(&quot;class1&quot;, 123, &quot;xiaoming&quot;);</code></li><li><strong>返回有序集合key的基数:</strong> <code>jedis.zcard(&quot;class1&quot;);</code></li><li><strong>返回有序集合中score值在min和max之间的成员的数量:</strong> <code>jedis.zcount(&quot;class1&quot;, 124, 125);</code></li><li><strong>返回有序集合中score值在min和max之间的成员的member:</strong> <code>jedis.zrevrangeByScore(&quot;class1&quot;, 130, 120);</code></li><li><strong>返回指定区间内的成员(score小-&gt;大):</strong> <code>//区间为负为倒序&lt;br&gt;jedis.zrange(&quot;class1&quot;, 0, -1);</code></li><li><strong>返回指定区间内的成员(score大-&gt;小):</strong> <code>jedis.zrevrange(&quot;class1&quot;, 0, -1);</code></li><li><strong>使member的score增加increment:</strong> <code>jedis.zincrby(&quot;class1&quot;, 12, &quot;xiaoming&quot;);</code></li><li><strong>查看member的score:</strong> <code>jedis.zscore(&quot;class1&quot;, &quot;xiaoming&quot;);</code></li><li><strong>查看有序集合中member的排名(小-&gt;大):</strong> <code>jedis.zrank(&quot;class1&quot;, &quot;sad&quot;);</code></li><li><strong>移除有序集合中的一个或多个成员,不存在将忽略:</strong> <code>jedis.zrem(&quot;class1&quot;,&quot;xiaoming&quot;,&quot;sad&quot;,&quot;xiaowang&quot;)；</code></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>排行榜应用，取TOP N操作</li><li>延时任务</li><li>范围查找</li></ul><hr><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><ul><li>“跳跃列表”<ul><li>如图<br><br><img src="./img/skiplist.jpg" alt="skiplist.jpg">  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">跳跃表在redis中主要是有序表的一种底层实现。对于普通链表的查找，即使有序，我们也不能使用二分法，需要从头开始，一个一个找，时间复杂度为O(n)。</span><br><span class="line">而对于跳跃表，从名字可以看出跳跃表的优势就在于可以跳跃。如何做到呢？</span><br><span class="line">在于其特殊的层设计。比如我们查找46，普通链表只能从头开始查找，比对-3,2,17...直到46，要比对7次。</span><br><span class="line">但是对于跳跃表，我们可以从最高层开始查找：</span><br><span class="line">    </span><br><span class="line">第一步：在L4层直接与55比对，发现大了，退回到第3层</span><br><span class="line">    </span><br><span class="line">第二步：在L3层与21比对，发现小了，继续往前比对55，发现大了，退回到第二层</span><br><span class="line"></span><br><span class="line">第三步：在L2层与37比对，发现小了，往前，与55比对，发现大了，退回到第一层</span><br><span class="line"></span><br><span class="line">第四步：在第1层，与46比对，查找成功。</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「OliverAAAAAA」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;OliverAAAAAA&#x2F;article&#x2F;details&#x2F;89184018</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据结构 </tag>
            
            <tag> 跳跃链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构-快速链表</title>
      <link href="/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/02/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-操作列表类型-类似于LinkedList"><a href="#Java-操作列表类型-类似于LinkedList" class="headerlink" title="Java 操作列表类型(类似于LinkedList)"></a>Java 操作列表类型(类似于LinkedList)</h2><ul><li><strong>在列表头部添加数据:</strong> <code>jedis.lpush(&quot;list&quot;, &quot;xiaoming&quot;,&quot;age&quot;,&quot;20&quot;,&quot;address&quot;,&quot;beijing&quot;);</code></li><li><strong>在列表尾部添加数据:</strong> <code>jedis.rpush(&quot;height&quot;,&quot;170cm&quot;,&quot;hobby&quot;,&quot;dance&quot;);</code></li><li><strong>列表长度:</strong> <code>jedis.llen(&quot;list&quot;)</code></li><li><strong>列表list下标为2的元素:</strong> <code>jedis.lindex(&quot;list&quot;,2);</code></li><li><strong>移除一个元素:</strong> <code>jedis.lrem(&quot;list&quot;,1,&quot;age&quot;)</code></li><li><strong>将列表key下标为index的元素值设置为value:</strong> <code>jedis.lset(&quot;list&quot;,5,&quot;hello world&quot;);</code></li><li><strong>移除并返回list尾元素:</strong> <code>jedis.rpop(&quot;list&quot;);</code></li><li>取值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>简单的消息队列</li><li>利用lrange命令，做基于redis的分页功能</li></ul><hr><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><ul><li>Redis底层存储是”快速链表(quickList)”结构<ul><li>在<font color=#FF2941>列表元素较少</font>的情况下,会使用一块连续的内存存储,这个结构是ziplist(压缩列表)。</li><li><font color=#FF2941>数据量多</font>时改为quicklist。</li><li>Redis将链表和ziplist结合起来组成了quicklist,将多个ziplist使用双向指针串起来使用</li><li>使用List作为异步消息队列<ul><li><strong>问题1:</strong> 队列空了怎么办?<br><br>&emsp;&emsp;&emsp;&nbsp;<br>当队列为空时,客户端就会陷入空轮询的pop-&gt;无数据-&gt;pop的死循环中。<br>所以采用堵塞读方法  <code>blpop</code>和<code>brpop</code><br>堵塞读在队列没有数据时,会立即进入休眠状态,一旦数据到来,则立刻醒过来。消息延迟几乎为0</li><li><strong>问题2:</strong> 空闲链接自动断开<br><br>&emsp;&emsp;&emsp;&nbsp;<br>如果线程一直堵塞在那里,Redis的客户端就成了闲置连接,闲置过久,服务器一般会主动断开,减少闲置资源占用。<br>这时blpop/brpop会抛出异常。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis数据结构 </tag>
            
            <tag> 快速链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis扩展类型-位图</title>
      <link href="/2020/05/02/Redis%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B-%E4%BD%8D%E5%9B%BE/"/>
      <url>/2020/05/02/Redis%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B-%E4%BD%8D%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><hr><ul><li>什么时候需要用到位图?<ul><li>平时开发中有一些bool型数据需要存储,比如用户一年的签到记录。为了解决存储空间,Redis提供了位图数据结构,这样365天就是365位,46个字节。</li></ul></li><li>位图是什么?<ul><li>其实就是普通的字符串,也就是byte数组。</li></ul></li><li>怎么使用位图?<ul><li>可以使用普通的get/set直接获取和设置整个位图的内容,也可以使用位图操作getbit/setbit等将byte数组看成”位数组”来处理。</li></ul></li></ul><hr><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li><p>Redis的位数组是自动扩展的,如果设置了某个偏移位置超出了现有的内容范围,就会自动将位数组进行零扩充。</p></li><li><p>零存整取</p><ul><li>h的ASCII码:0b1101000<br>e的ASCII码:0b1100101  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit s 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 9 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 10 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 13 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 15 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line">"he"</span><br></pre></td></tr></table></figure></li></ul></li><li><p>整存零取</p><ul><li>h的ASCII码:0b1101000  <figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set w h</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit w 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果对应位的字节是不可打印字符,redis-cli会显示该字符的十六进制形式</p></li><li><p>Redis提供了位图统计指令bitcount和位图查找指令bitpos</p><ul><li><strong>bitcount:</strong> 用来统计指定位置范围内的1的个数。<ul><li>统计用户一共签到多少天</li></ul></li><li><strong>bitpos:</strong> 用来查找指定范围内出现的第一个0或1。  <ul><li>查找用户从哪一天开始第一次签到。 </li></ul></li><li>如果指定范围参数[start,end],就可以统计在某个时间范围内用户签到了多少天，用户自某天以后哪天开始签到</li><li>但start和end是字节索引,所以指定的位范围必须是<font color=#ff4911>8的倍数</font></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本类型-有序集合</title>
      <link href="/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
      <url>/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Java操作有序集合SortedSet"><a href="#Java操作有序集合SortedSet" class="headerlink" title="Java操作有序集合SortedSet"></a>Java操作有序集合SortedSet</h2><ul><li><strong>插入score和member到有序集合key中:</strong> <code>jedis.zadd(&quot;class1&quot;, 123, &quot;xiaoming&quot;);</code></li><li><strong>返回有序集合key的基数:</strong> <code>jedis.zcard(&quot;class1&quot;);</code></li><li><strong>返回有序集合中score值在min和max之间的成员的数量:</strong> <code>jedis.zcount(&quot;class1&quot;, 124, 125);</code></li><li><strong>返回有序集合中score值在min和max之间的成员的member:</strong> <code>jedis.zrevrangeByScore(&quot;class1&quot;, 130, 120);</code></li><li><strong>返回指定区间内的成员(score小-&gt;大):</strong> <code>//区间为负为倒序&lt;br&gt;jedis.zrange(&quot;class1&quot;, 0, -1);</code></li><li><strong>返回指定区间内的成员(score大-&gt;小):</strong> <code>jedis.zrevrange(&quot;class1&quot;, 0, -1);</code></li><li><strong>使member的score增加increment:</strong> <code>jedis.zincrby(&quot;class1&quot;, 12, &quot;xiaoming&quot;);</code></li><li><strong>查看member的score:</strong> <code>jedis.zscore(&quot;class1&quot;, &quot;xiaoming&quot;);</code></li><li><strong>查看有序集合中member的排名(小-&gt;大):</strong> <code>jedis.zrank(&quot;class1&quot;, &quot;sad&quot;);</code></li><li><strong>移除有序集合中的一个或多个成员,不存在将忽略:</strong> <code>jedis.zrem(&quot;class1&quot;,&quot;xiaoming&quot;,&quot;sad&quot;,&quot;xiaowang&quot;)；</code></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>排行榜应用，取TOP N操作</li><li>延时任务</li><li>范围查找</li></ul><hr><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><ul><li>“跳跃列表”<ul><li>如图<br><br><img src="./img/skiplist.jpg" alt="skiplist.jpg">  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">跳跃表在redis中主要是有序表的一种底层实现。对于普通链表的查找，即使有序，我们也不能使用二分法，需要从头开始，一个一个找，时间复杂度为O(n)。</span><br><span class="line">而对于跳跃表，从名字可以看出跳跃表的优势就在于可以跳跃。如何做到呢？</span><br><span class="line">在于其特殊的层设计。比如我们查找46，普通链表只能从头开始查找，比对-3,2,17...直到46，要比对7次。</span><br><span class="line">但是对于跳跃表，我们可以从最高层开始查找：</span><br><span class="line">    </span><br><span class="line">第一步：在L4层直接与55比对，发现大了，退回到第3层</span><br><span class="line">    </span><br><span class="line">第二步：在L3层与21比对，发现小了，继续往前比对55，发现大了，退回到第二层</span><br><span class="line"></span><br><span class="line">第三步：在L2层与37比对，发现小了，往前，与55比对，发现大了，退回到第一层</span><br><span class="line"></span><br><span class="line">第四步：在第1层，与46比对，查找成功。</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「OliverAAAAAA」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;OliverAAAAAA&#x2F;article&#x2F;details&#x2F;89184018</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本类型-哈希类型</title>
      <link href="/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java操作哈希类型"><a href="#Java操作哈希类型" class="headerlink" title="Java操作哈希类型"></a>Java操作哈希类型</h2><ul><li><strong>将fiele:value插入Hash表key中:</strong> <code>jedis.hset(&quot;bigcity&quot;,&quot;big&quot;,&quot;beijing&quot;);</code></li><li><strong>获取Hash表key中域为feild的value:</strong> <code>jedis.hget(&quot;bigcity&quot;,&quot;big&quot;);</code></li><li><strong>插入一个map至Hash表key中:</strong> <code>jedis.hmset(&quot;bigCity2&quot;,map);</code></li><li><strong>通过List接收从Hash表key中返回的多个域:</strong> <code>List&lt;String&gt; list = jedis.hmget(&quot;bigCity2&quot;,&quot;big1&quot;,&quot;big2&quot;);</code></li><li><strong>删除Hash表key中的多个feild:</strong> <code>jedis.hdel(&quot;bigCity2&quot;,&quot;big1&quot;,&quot;big2&quot;);</code></li><li><strong>获取Hash表的长度:</strong> <code>jedis.hlen(&quot;bigcity&quot;);</code></li><li><strong>是否存在Hash表key:</strong> <code>jedis.exists(&quot;bigCity2&quot;);</code></li><li><strong>返回Hash表中所有feilds:</strong> <code>jedis.hkeys(&quot;bigCity2&quot;)</code></li><li><strong>返回Hash表中所有values:</strong> <code>jedis.hvals(&quot;bigCity2&quot;)</code></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>操作某个字段</li></ul><hr><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><ul><li>rehash<ul><li>Redis为追求高性能,不堵塞服务,所以采用渐进式rehash策略。</li><li><strong>渐进式rehash:</strong> <br>在rehash同时保留两个hash结构,查询时会查询两个hash结构。<br><br>在后续的定时任务以及hash操作指令中,循序渐进地将旧hash的内容一点点地迁移到新的hash结构中。<br><br>当hash移除了最后一个元素之后,该数据结构被自动删除,内存被回收。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本类型-集合类型</title>
      <link href="/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="java操作Redis集合类型"><a href="#java操作Redis集合类型" class="headerlink" title="java操作Redis集合类型"></a>java操作Redis集合类型</h2><ul><li><strong>添加集合元素:</strong> <code>jedis.sadd(&quot;city&quot;,&quot;北京&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;上海&quot;);</code></li><li><strong>取集合头部元素:</strong> <code>jedis.spop(&quot;city&quot;);</code></li><li><strong>随机取一个值:</strong> <code>jedis.srandmember(&quot;city&quot;);</code></li><li><strong>Srem移除集合中一或多个元素,不存在的元素会被忽略.当key不是集合类型时,返回一个错误:</strong> <code>jedis.screm(&quot;city&quot;,&quot;北京&quot;)</code></li><li><strong>Smember用于返回集合中的所有成员.不存在的集合key视为空集合:</strong> <code>jedis.smember(&quot;city&quot;);</code></li><li><strong>判断元素是否在集合中:</strong> <code>jedis.sismember(&quot;city&quot;,&quot;深圳&quot;;</code></li><li><strong>Scard用于返回集合中元素的数量:</strong> <code>jedis.scard(&quot;city&quot;);</code></li><li><strong>求交集:</strong> <code>jedis.sinter(&quot;city1&quot;,&quot;city2&quot;);</code></li><li><strong>求并集:</strong> <code>jedis.sunion(&quot;city1&quot;,&quot;city2&quot;);</code></li><li><strong>求差集:</strong> <code>jedis.sdiff(&quot;city1&quot;,&quot;city2&quot;);</code></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>全局去重</li><li>利用交集、并集、差集等操作,计算共同喜好，全部的喜好，自己独有的喜好等功能.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本类型-列表类型</title>
      <link href="/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-操作列表类型-类似于LinkedList"><a href="#Java-操作列表类型-类似于LinkedList" class="headerlink" title="Java 操作列表类型(类似于LinkedList)"></a>Java 操作列表类型(类似于LinkedList)</h2><ul><li><strong>在列表头部添加数据:</strong> <code>jedis.lpush(&quot;list&quot;, &quot;xiaoming&quot;,&quot;age&quot;,&quot;20&quot;,&quot;address&quot;,&quot;beijing&quot;);</code></li><li><strong>在列表尾部添加数据:</strong> <code>jedis.rpush(&quot;height&quot;,&quot;170cm&quot;,&quot;hobby&quot;,&quot;dance&quot;);</code></li><li><strong>列表长度:</strong> <code>jedis.llen(&quot;list&quot;)</code></li><li><strong>列表list下标为2的元素:</strong> <code>jedis.lindex(&quot;list&quot;,2);</code></li><li><strong>移除一个元素:</strong> <code>jedis.lrem(&quot;list&quot;,1,&quot;age&quot;)</code></li><li><strong>将列表key下标为index的元素值设置为value:</strong> <code>jedis.lset(&quot;list&quot;,5,&quot;hello world&quot;);</code></li><li><strong>移除并返回list尾元素:</strong> <code>jedis.rpop(&quot;list&quot;);</code></li><li>取值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>简单的消息队列</li><li>利用lrange命令，做基于redis的分页功能</li></ul><hr><h4 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h4><ul><li>Redis底层存储是”快速链表(quickList)”结构<ul><li>在<font color=#FF2941>列表元素较少</font>的情况下,会使用一块连续的内存存储,这个结构是ziplist(压缩列表)。</li><li><font color=#FF2941>数据量多</font>时改为quicklist。</li><li>Redis将链表和ziplist结合起来组成了quicklist,将多个ziplist使用双向指针串起来使用</li><li>使用List作为异步消息队列<ul><li><strong>问题1:</strong> 队列空了怎么办?<br><br>&emsp;&emsp;&emsp;&nbsp;<br>当队列为空时,客户端就会陷入空轮询的pop-&gt;无数据-&gt;pop的死循环中。<br>所以采用堵塞读方法  <code>blpop</code>和<code>brpop</code><br>堵塞读在队列没有数据时,会立即进入休眠状态,一旦数据到来,则立刻醒过来。消息延迟几乎为0</li><li><strong>问题2:</strong> 空闲链接自动断开<br><br>&emsp;&emsp;&emsp;&nbsp;<br>如果线程一直堵塞在那里,Redis的客户端就成了闲置连接,闲置过久,服务器一般会主动断开,减少闲置资源占用。<br>这时blpop/brpop会抛出异常。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本类型-字符类型</title>
      <link href="/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/02/Redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-操作字符类型"><a href="#Java-操作字符类型" class="headerlink" title="Java 操作字符类型"></a>Java 操作字符类型</h2><ul><li><strong>查看键为mykey的值是否存在:</strong> <code>jedis.exists(&quot;mykey&quot;);</code></li><li><strong>键mykey的值为:</strong> <code>jedis.get(&quot;mykey&quot;);</code></li><li><strong>查看键为mykey的类型:</strong> <code>jedis.type(&quot;mykey&quot;);</code></li><li><strong>随机获得一个key:</strong> <code>jedis.randomKey(&quot;mykey&quot;);</code></li><li><strong>将mykey重命名为mykey1:</strong> <code>jedis.rename(&quot;mykey&quot;,&quot;mykey1&quot;);</code></li><li><strong>删除key “mykey”:</strong> <code>jedis.del(&quot;mykey&quot;);</code></li></ul><hr><ul><li><strong>设置name:</strong> <code>jedis.set(&quot;name&quot;,&quot;asd&quot;);</code></li><li><strong>设置name,如果存在返回0:</strong> <code>jedis.setnx(&quot;name&quot;,&quot;asd&quot;);</code></li><li><strong>获取key为name的值:</strong> <code>jedis.get(&quot;name&quot;)</code> </li><li><strong>获取key为name和name1的value值:</strong> <code>jedis.mget(&quot;name&quot;,&quot;name1&quot;);</code></li><li><strong>自增1:</strong> <code>jedis.incr(&quot;index&quot;)</code> </li><li><strong>自增2:</strong> <code>jedis.inceBy(&quot;index&quot;)</code> </li><li><strong>递减1:</strong> <code>jedis.decr(&quot;index&quot;)</code></li><li><strong>递减2:</strong> <code>jedis.decrBy(&quot;index&quot;)</code></li><li><strong>在name后添加String:</strong> <code>jedis.append(&quot;name&quot;,&quot;asd&quot;)</code></li></ul><hr><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>复杂的计数功能的缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote><p>将某个类的接口转换成客户端期望的另一个接口表示。使得原本由于接口不兼容而不能一起工作的那些类能在一起工作。</p></blockquote><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类适配器 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        充电器 phone = <span class="keyword">new</span> 手机();</span><br><span class="line">        System.out.println(phone.高压转低压());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 高压电</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 插座()&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 充电器</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> 高压转低压();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机 <span class="keyword">extends</span> 高压电 <span class="keyword">implements</span> 充电器</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 高压转低压() &#123;</span><br><span class="line">        <span class="keyword">int</span> 高压电 = 插座();</span><br><span class="line">        <span class="comment">//适配细节</span></span><br><span class="line">        <span class="keyword">int</span> 低压电 = 高压电/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> 低压电;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类适配器 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        充电器 phone = <span class="keyword">new</span> 手机();</span><br><span class="line">        System.out.println(phone.高压转低压());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 高压电 <span class="keyword">implements</span> 充电器</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 插座()&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 充电器</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> 高压转低压();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机 <span class="keyword">extends</span> 高压电</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 高压转低压() &#123;</span><br><span class="line">        <span class="keyword">int</span> 高压电 = 插座();</span><br><span class="line">        <span class="comment">//适配细节</span></span><br><span class="line">        <span class="keyword">int</span> 低压电 = 高压电/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> 低压电;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><blockquote><p>对象适配器拥有源角色的实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 对象适配器 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        充电器 phone = <span class="keyword">new</span> 手机对象(<span class="keyword">new</span> 高压电());</span><br><span class="line">        System.out.println(phone.高压转低压());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机对象 <span class="keyword">extends</span> 高压电 <span class="keyword">implements</span> 充电器</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> 高压电 伏<span class="number">220</span>高压电;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机对象(高压电 伏<span class="number">220</span>高压电) &#123;</span><br><span class="line">        <span class="keyword">this</span>.伏<span class="number">220</span>高压电 = 伏<span class="number">220</span>高压电;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 高压转低压() &#123;</span><br><span class="line">        <span class="keyword">int</span> 高压电 = 伏<span class="number">220</span>高压电.插座();</span><br><span class="line">        <span class="comment">//适配细节</span></span><br><span class="line">        <span class="keyword">int</span> 低压电 = 高压电/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> 低压电;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><blockquote><p>通过抽象类来实现适配</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 接口适配器 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        手机输入 phone = <span class="keyword">new</span> 手机适配器(<span class="keyword">new</span> 工业插座());</span><br><span class="line">        System.out.println(<span class="string">"输出后电压"</span>+phone.输入电压());</span><br><span class="line">        phone = <span class="keyword">new</span> 手机适配器(<span class="keyword">new</span> 家庭插座());</span><br><span class="line">        System.out.println(<span class="string">"输出后电压"</span>+phone.输入电压());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 插座</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 输出电压()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 家庭插座 <span class="keyword">extends</span> 插座</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 输出电压() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 工业插座 <span class="keyword">extends</span> 插座</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 输出电压() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">440</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 手机输入</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> 输入电压();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机适配器 <span class="keyword">implements</span> 手机输入</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> 插座 chazuo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机适配器(家庭插座 jiatingchazuo) &#123;</span><br><span class="line">        <span class="keyword">this</span>.chazuo = jiatingchazuo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机适配器(工业插座 gongyechazuo) &#123;</span><br><span class="line">        <span class="keyword">this</span>.chazuo = gongyechazuo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> 输入电压() &#123;</span><br><span class="line">        <span class="keyword">if</span> (chazuo !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输出前电压:"</span>+chazuo.输出电压());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//适配逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景<ul><li>项目接口的新需求，不用更改老代码，实现代码兼容</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 观察者模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        运营商 电信运营商 = <span class="keyword">new</span> 电信运营商();</span><br><span class="line">        电信运营商.增加用户(<span class="keyword">new</span> 苹果手机用户(<span class="number">138</span>));</span><br><span class="line">        电信运营商.增加用户(<span class="keyword">new</span> 苹果手机用户(<span class="number">136</span>));</span><br><span class="line">        电信运营商.增加用户(<span class="keyword">new</span> 安卓手机用户(<span class="number">158</span>));</span><br><span class="line">        电信运营商.发送短信(<span class="string">"开会"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 电信用户</span>&#123; <span class="comment">//Observe</span></span><br><span class="line">    <span class="keyword">void</span> 接受短信(String message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 苹果手机用户 <span class="keyword">implements</span> 电信用户</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 苹果手机用户(<span class="keyword">int</span> phone) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 接受短信(String message) &#123;</span><br><span class="line">        System.out.println(<span class="string">"iPhone:"</span>+phone+<span class="string">";电信短信:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 安卓手机用户 <span class="keyword">implements</span> 电信用户</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 安卓手机用户(<span class="keyword">int</span> phone) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 接受短信(String message) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Android:"</span>+phone+<span class="string">";移动短信:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> 运营商</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 增加用户(电信用户 user);</span><br><span class="line">    <span class="keyword">void</span> 发送短信(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 电信运营商 <span class="keyword">implements</span> 运营商</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;电信用户&gt; 用户们 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 增加用户(电信用户 user) &#123;</span><br><span class="line">        用户们.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 发送短信(String message) &#123;</span><br><span class="line">        用户们.forEach(电信用户 -&gt; &#123;</span><br><span class="line">            电信用户.接受短信(message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与策略模式一样，如果接口仅有一个方法，可以不需要实现具体观察者对象，如苹果手机用户、安卓手机用户</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 观察者模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        运营商 电信运营商 = <span class="keyword">new</span> 电信运营商();</span><br><span class="line">        电信运营商.增加用户((String message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"安卓电信短信:"</span>+message);</span><br><span class="line">        &#125;);</span><br><span class="line">        电信运营商.增加用户((String message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"苹果电信短信:"</span>+message);</span><br><span class="line">        &#125;);</span><br><span class="line">        电信运营商.发送短信(<span class="string">"开会"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> 电信用户</span>&#123; <span class="comment">//Observe</span></span><br><span class="line">    <span class="keyword">void</span> 接受短信(String message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 运营商</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 增加用户(电信用户 user);</span><br><span class="line">    <span class="keyword">void</span> 发送短信(String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 电信运营商 <span class="keyword">implements</span> 运营商</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;电信用户&gt; 用户们 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 增加用户(电信用户 user) &#123;</span><br><span class="line">        用户们.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 发送短信(String message) &#123;</span><br><span class="line">        用户们.forEach(电信用户 -&gt; &#123;</span><br><span class="line">            电信用户.接受短信(message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰器模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 装饰器模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        手机父类 iPhone = <span class="keyword">new</span> 苹果手机();</span><br><span class="line">        手机装饰 加个壳 = <span class="keyword">new</span> 手机壳(iPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String description;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 外观()&#123;</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 安卓手机 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 安卓手机() &#123;</span><br><span class="line">        description = <span class="string">"安卓手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 苹果手机 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 苹果手机() &#123;</span><br><span class="line">        description = <span class="string">"苹果手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 手机装饰 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 手机父类 phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机装饰(手机父类 phone) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> 输出外观()&#123;</span><br><span class="line">        <span class="keyword">if</span> (phone!=<span class="keyword">null</span>)</span><br><span class="line">            phone.外观();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机壳 <span class="keyword">extends</span> 手机装饰</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机壳(手机父类 phone) &#123;</span><br><span class="line">        <span class="keyword">super</span>(phone);</span><br><span class="line">        <span class="keyword">this</span>.输出外观();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 输出外观() &#123;</span><br><span class="line">        <span class="keyword">super</span>.输出外观();</span><br><span class="line">        System.out.println(<span class="string">"增加手机壳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如新增功能 ,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 装饰器模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        手机父类 iPhone = <span class="keyword">new</span> 苹果手机();</span><br><span class="line">        手机装饰 加个壳 = <span class="keyword">new</span> 手机壳(iPhone);</span><br><span class="line">        手机装饰 贴个膜 = <span class="keyword">new</span> 贴膜(iPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String description;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 外观()&#123;</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 安卓手机 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 安卓手机() &#123;</span><br><span class="line">        description = <span class="string">"安卓手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 苹果手机 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> 苹果手机() &#123;</span><br><span class="line">        description = <span class="string">"苹果手机"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 手机装饰 <span class="keyword">extends</span> 手机父类</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 手机父类 phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机装饰(手机父类 phone) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> 输出外观()&#123;</span><br><span class="line">        <span class="keyword">if</span> (phone!=<span class="keyword">null</span>)</span><br><span class="line">            phone.外观();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 手机壳 <span class="keyword">extends</span> 手机装饰</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 手机壳(手机父类 phone) &#123;</span><br><span class="line">        <span class="keyword">super</span>(phone);</span><br><span class="line">        <span class="keyword">this</span>.输出外观();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 输出外观() &#123;</span><br><span class="line">        <span class="keyword">super</span>.输出外观();</span><br><span class="line">        System.out.println(<span class="string">"增加手机壳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 贴膜 <span class="keyword">extends</span> 手机装饰</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 贴膜(手机父类 phone) &#123;</span><br><span class="line">        <span class="keyword">super</span>(phone);</span><br><span class="line">        <span class="keyword">this</span>.输出外观();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 输出外观() &#123;</span><br><span class="line">        <span class="keyword">super</span>.输出外观();</span><br><span class="line">        System.out.println(<span class="string">"贴膜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用目的<ul><li>动态给对象添加额外职责</li></ul></li><li>应用场景<ul><li>FileInputStream/FileOutputStream</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 策略模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> 微信支付());</span><br><span class="line">        context.收钱();</span><br><span class="line">        context.付钱();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 支付</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 付钱();</span><br><span class="line">    <span class="keyword">void</span> 收钱();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 微信支付 <span class="keyword">implements</span> 支付</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 付钱() &#123;</span><br><span class="line">        System.out.println(<span class="string">"微信付钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 收钱() &#123;</span><br><span class="line">        System.out.println(<span class="string">"微信收钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 支付宝支付 <span class="keyword">implements</span> 支付</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 付钱() &#123;</span><br><span class="line">        System.out.println(<span class="string">"支付宝付钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 收钱() &#123;</span><br><span class="line">        System.out.println(<span class="string">"支付宝收钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 支付 pay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(支付 payWay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pay = payWay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 付钱() &#123;</span><br><span class="line">        pay.付钱();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 收钱() &#123;</span><br><span class="line">        pay.收钱();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>上下文和具体策略是松耦合关系。</li><li>策略模式满足”开闭原则”，当新增具体策略时不需修改上下文代码。</li></ul></li><li>场景<ul><li>如果程序不希望暴露内部细节，可以使用策略模式封装</li></ul></li><li>应用<ul><li><code>Arrays.sort(Object[],Comparator)</code>和<code>Collections.sort(List,Comparator)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 策略模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] integers = &#123;</span><br><span class="line">                <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> Integer(<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Integer(<span class="number">5</span>)</span><br><span class="line">        &#125; ;</span><br><span class="line">        Arrays.sort(integers,<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ((Integer) o2).intValue()-((Integer) o1).intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Lambda表达式简化策略模式"><a href="#使用Lambda表达式简化策略模式" class="headerlink" title="使用Lambda表达式简化策略模式"></a>使用Lambda表达式简化策略模式</h3><blockquote><p>前提：函数接口(@FunctionalInterface)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 策略模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context((<span class="keyword">int</span> money)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"微信付钱"</span>+money);</span><br><span class="line">        &#125;);</span><br><span class="line">        context.付钱(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> 支付</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 付钱(<span class="keyword">int</span> money);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 支付 pay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(支付 payWay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pay = payWay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 付钱(<span class="keyword">int</span> money) &#123;</span><br><span class="line">        pay.付钱(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>目标类和代理类实现同一接口</li><li>对功能进行增强</li><li>缺点: 因为目标类和代理类实现了同一接口，此时接口一旦发生改变，两个类都必须同时实现新增的功能（动态代理可以解决这一缺点）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 静态代理 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        数学老师 mathTeacher1 = <span class="keyword">new</span> 数学老师();</span><br><span class="line">        数学教授 mathTeacher2 = <span class="keyword">new</span> 数学教授(mathTeacher1);</span><br><span class="line">        mathTeacher2.教书();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 老师</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 教书();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 数学老师 <span class="keyword">implements</span> 老师</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 教书() &#123;</span><br><span class="line">        System.out.println(<span class="string">"教数学"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 数学教授 <span class="keyword">implements</span> 老师</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> 数学老师 math;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 数学教授(数学老师 math) &#123;</span><br><span class="line">        <span class="keyword">this</span>.math = math;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 教书() &#123;</span><br><span class="line">        System.out.println(<span class="string">"教物理"</span>);</span><br><span class="line">        math.教书();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 动态代理 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> 董事长(),<span class="keyword">new</span> 助理());</span><br><span class="line">        职工 worker = (职工)dynamicProxy.newInstance();</span><br><span class="line">        worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 职工</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 董事长 <span class="keyword">implements</span> 职工</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做董事长该干的事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 助理 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"work前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"work后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="keyword">private</span> 助理 helper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object, 助理 helper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">this</span>.helper = helper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="keyword">this</span>.object.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(clas.getClassLoader(), clas.getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                helper.beforeWork();</span><br><span class="line">                Object obj = method.invoke(object,args);</span><br><span class="line">                helper.afterWork();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><ul><li>Spring中AOP的实现原理就是用的代理模式–&gt;动态代理+Cglib代理<ul><li>如果目标类实现了接口，Spring底层AOP就调用动态代理，否则调用Cglib代理</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cglib</span>代理 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CrudDaoInterceptor interceptor = <span class="keyword">new</span> CrudDaoInterceptor(<span class="keyword">new</span> CrudDaoImpl(),<span class="keyword">new</span> Transaction());</span><br><span class="line">        CrudDaoImpl proxy = (CrudDaoImpl) interceptor.getObject();</span><br><span class="line">        proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrudDaoImpl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"select * from table"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"insert into table values()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete from table where id = ?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"update table set id = ? where name = ?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrudDaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="keyword">private</span> Transaction transaction; <span class="comment">//切面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CrudDaoInterceptor</span><span class="params">(Object object, Transaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">this</span>.object.getClass();</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        enhancer.setInterfaces(clazz.getInterfaces());</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(<span class="string">"执行的方法名为:"</span>+methodName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"delete"</span>.equals(methodName))&#123;</span><br><span class="line">            transaction.openTransaction();</span><br><span class="line">            method.invoke(object,objects);</span><br><span class="line">            transaction.commitTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-享元模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>用于减少创建对象的数量 如String</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 享元模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        字符串 string1 = 对象工厂.getChars(<span class="string">"a"</span>);</span><br><span class="line">        string1.print();</span><br><span class="line">        字符串 string2 = 对象工厂.getChars(<span class="string">"a"</span>);</span><br><span class="line">        string2.print();</span><br><span class="line">        字符串 string3 = 对象工厂.getChars(<span class="string">"b"</span>);</span><br><span class="line">        string3.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> 对象</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 字符串 <span class="keyword">implements</span> 对象</span>&#123;</span><br><span class="line">    String chars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 字符串(String chars) &#123;</span><br><span class="line">        <span class="keyword">this</span>.chars = chars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChars</span><span class="params">(String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chars = chars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 对象工厂</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,字符串&gt; 字符串对象池 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> 字符串 getChars(String chars)&#123;</span><br><span class="line">        字符串 字符串对象 = 字符串对象池.get(chars);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (字符串对象 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            字符串对象 = <span class="keyword">new</span> 字符串(chars);</span><br><span class="line">            字符串对象池.put(chars,字符串对象);</span><br><span class="line">            System.out.println(<span class="string">"向字符串对象池插入一个对象:"</span>+字符串对象.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> 字符串对象;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景<ul><li>系统中有大量相似对象</li><li>缓冲池场景</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 享元模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="生成者模式-Build"><a href="#生成者模式-Build" class="headerlink" title="生成者模式 Build"></a>生成者模式 Build</h2><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@USER</span>: lynn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/4/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car audi = <span class="keyword">new</span> Car.Builder()</span><br><span class="line">                .color(Color.BLACK)</span><br><span class="line">                .money(<span class="number">300000</span>)</span><br><span class="line">                .kind(<span class="string">"A4"</span>)</span><br><span class="line">                .year(<span class="number">2020</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(audi.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String kind;</span><br><span class="line">    Color color;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        setKind(builder.kind);</span><br><span class="line">        setColor(builder.color);</span><br><span class="line">        setYear(builder.year);</span><br><span class="line">        setMoney(builder.money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKind</span><span class="params">(String kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String kind;</span><br><span class="line">        <span class="keyword">private</span> Color color;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">kind</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            kind = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">color</span><span class="params">(Color val)</span> </span>&#123;</span><br><span class="line">            color = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">year</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            year = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">money</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            money = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用场景 <ul><li>Android中，对话框的创建</li><li>OkHttp</li></ul></li><li>优点<ul><li>避免过多setter方法，并且隐藏内部细节</li><li>链式调用，简洁易懂。</li></ul></li><li>缺点<ul><li>内部类与外部类相互引用，可能会导致内存消耗比较大</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p>创建多个子类工厂</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AudiCar();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryUser</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CarFactory audiFactory = <span class="keyword">new</span> AudiFactory();</span><br><span class="line">        Car audi = audiFactory.createCar();</span><br><span class="line">        System.out.println(audi.drive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单-静态工厂模式"><a href="#简单-静态工厂模式" class="headerlink" title="简单/静态工厂模式"></a>简单/静态工厂模式</h3><blockquote><p>缺点：如果需要其他对象就要改代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Audi"</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Car audiCar = CarFactory.createCar(<span class="string">"Audi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><blockquote><p>线程安全</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//直接创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//    声明变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    提供对外方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
